<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- Updated CSP -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline';
        style-src 'self' 'unsafe-inline';
        img-src 'self' data: https:;
        media-src 'self' data:;  
        connect-src 'self' ws: wss: http: https:;
        font-src 'self';
        object-src 'none';
    ">
    <title>Thor-Grid</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        @supports (padding: env(safe-area-inset-top)) {
            body {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
        }

        .token-name {
            position: fixed;
            pointer-events: none;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 8px;
            padding-bottom: 3px; /* <--- Add this line (adjust value as needed) */
            border-radius: 4px;
            font-size: 16px;
            font-family: Arial, sans-serif;
            white-space: nowrap;
            z-index: 10;
            transform: translate(-50%, -100%);
            transition: opacity 0.2s ease;
        }

        .dark-mode .token-name {
            background-color: rgba(255, 255, 255, 0.7);
            color: black;
        }

        .token-name.hovered {
            opacity: 1 !important;
            font-weight: bold;
            background-color: rgba(0, 0, 255, 0.3);
            color: white;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }

        .dark-mode .token-name.hovered {
            background-color: rgba(0, 0, 255, 0.3);
            color: white;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }

        #grid-container, canvas {
            width: 100vw !important;
            height: 100vh !important;
            position: fixed;
            top: 0;
            left: 0;
        }

        body {
            background-color: white;
            color: black;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            border: 1px solid black;
            background-color: transparent;
            touch-action: none;
        }

        body.dark-mode {
            background-color: #121212;
            color: white;
        }

        canvas.dark-mode {
            border: 1px solid white;
        }

        #grid-container {
            position: relative;
            overflow: hidden;
        }

        #add-token-form, #player-token-form, #background-form {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
        }

        #add-token-form.dark-mode, #player-token-form.dark-mode, #background-form.dark-mode {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
        }

        #add-token-form input,
        #add-token-form select,
        #player-token-form input,
        #player-token-form select,
        #background-form input,
        #background-form select {
            margin-bottom: 6px;
            padding: 6px;
            font-size: 14px;
        }

        #controls-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 11;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px;
            position: fixed;
            top: 10px;
            left: 10px;
            width: 220px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #controls-container.dark-mode {
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #core-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        details {
            margin-bottom: 8px;
        }

        summary {
            cursor: pointer;
            padding: 6px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
        }

        details[open] summary {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .dark-mode summary {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .dark-mode details[open] summary {
            background-color: rgba(255, 255, 255, 0.2);
        }

        #instructions {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.4;
        }

        #instructions.dark-mode {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
        }

        #toggle-instructions-button,
        #controls-container button,
        #add-token-form button,
        #player-token-form button,
        #background-form button {
            width: 100%;
            height: 36px;
            padding: 8px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
        }

        #background-form button {
            width: 48%;
        }

        #dark-mode-toggle {
            position: relative;
            z-index: 12;
        }

        #show-controls-button {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 12;
            padding: 10px 16px;
            background-color: #5bc0de;
            color: #333;
            border-radius: 6px;
            cursor: pointer;
            display: none;
            font-size: 16px;
            border: none;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        #show-controls-button.dark-mode {
            background-color: #337ab7;
            color: white;
            box-shadow: 2px 2px 5px rgba(255, 255, 255, 0.1);
        }

        #show-controls-button:hover {
            background-color: #46b8da;
        }

        #show-controls-button.dark-mode:hover {
            background-color: #286090;
        }

        #close-controls-button {
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            cursor: pointer;
            z-index: 13;
            margin-left: auto;
            align-self: flex-start;
        }

        #close-controls-button:hover {
            background-color: rgba(255, 0, 0, 0.9);
        }

        .controls-wrapper {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 11;
        }

        .token-context-menu {
            position: fixed;
            z-index: 1000;
            min-width: 140px;
            font-size: 14px;
        }

        .token-context-menu button,
        .token-context-menu input {
            padding: 6px;
            font-size: 14px;
        }

        .dm-only {
            display: none;
        }

        body.role-dm .dm-only {
            display: block;
        }

        .dm-controls {
            display: block;
        }

        body.role-player .dm-controls {
            display: none;
        }

        #loginScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
            display: block;
        }
        #loginScreen.dark-mode {
            background: rgba(0, 0, 0, 0.9);
            color: white;
        }
        #loginScreen input,
        #loginScreen select {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            font-size: 14px;
        }
        #loginScreen.hidden {
            display: none;
        }

        #notification {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            z-index: 1000;
            display: none;
            font-size: 14px;
        }

        #notification.dark-mode {
            background: rgba(255, 255, 255, 0.8);
            color: black;
        }

        #notification.error {
            background: rgba(255, 0, 0, 0.8);
        }

        #notification.error.dark-mode {
            background: rgba(255, 100, 100, 0.8);
            color: black;
        }
		
		#server-address-display {
            margin-top: 15px;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            font-size: 11px;
            line-height: 1.3;
            word-wrap: break-word; /* Ensure long addresses wrap */
        }
        #server-address-display.dark-mode {
             background-color: rgba(255, 255, 255, 0.1);
        }
        #server-address-display strong {
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="loginScreen">
        <h3>Join Session</h3>
        <label for="usernameInput">Username:</label>
        <input type="text" id="usernameInput" value="User" autocomplete="username">
        <label for="roleSelect">Role:</label>
        <select id="roleSelect">
            <option value="dm">DM</option>
            <option value="player" selected>Player</option>
        </select>
        <button id="loginButton">Join</button>
    </div>

    <!-- Notification Area -->
    <div id="notification"></div>

    <!-- Controls -->
    <div class="controls-wrapper" id="controls-wrapper">
        <div id="controls-container">
            <!-- Core Buttons -->
            <div id="core-buttons">
                <button id="dark-mode-toggle">Dark Mode</button>
                <button id="interact-button">Interact</button>
                <button id="reset-view-button">Reset View</button>
                <button id="toggle-grid-button" class="dm-controls">Hide Grid</button>
                <button id="draw-wall-button" class="dm-controls">Draw Walls</button>
                <button id="erase-wall-button" class="dm-controls">Erase Walls</button>
            </div>

            <!-- Save Controls -->
            <div id="save-controls" class="dm-controls">
                <button id="save-state-button" class="dm-controls">Save State</button>
                <button id="download-state-button" class="dm-controls">Download State</button>
                <button id="import-state-button" class="dm-controls">Import State</button>
                <input type="file" id="import-state-file" class="dm-controls" accept=".json" style="display: none;">
            </div>

            <details class="dm-controls">
                <summary>Tokens</summary>
                <form id="add-token-form">
                    <label for="token-name">Token Name:</label>
                    <input type="text" id="token-name" name="token-name" value="">
                    <label for="token-image">Token Image URL:</label>
                    <input type="text" id="token-image" name="token-image" value="">
                    <label for="token-image-file">Or Upload Image:</label>
                    <input type="file" id="token-image-file" name="token-image-file" accept="image/*">
                    <label for="token-color">Token Color:</label>
                    <input type="text" id="token-color" name="token-color">
                    <label for="token-size">Token Size:</label>
                    <select id="token-size" name="token-size">
                        <option value="1">1x1 (Medium)</option>
                        <option value="2">2x2 (Large)</option>
                        <option value="3">3x3 (Huge)</option>
                        <option value="4">4x4 (Gargantuan)</option>
                        <option value="6">6x6 (Colossal)</option>
                        <option value="8">8x8 (Titanic)</option>
                    </select>
                    <label for="token-rotation">Token Rotation (degrees):</label>
                    <input type="number" id="token-rotation" name="token-rotation" value="0" min="0" max="360" step="1">
                    <label for="token-max-hp" class="dm-only">Max HP:</label>
                    <input type="number" id="token-max-hp" name="token-max-hp" class="dm-only" value="0" min="0">
                    <label for="token-hp" class="dm-only">Current HP:</label>
                    <input type="number" id="token-hp" name="token-hp" class="dm-only" value="0" min="0">
                    <label for="token-init" class="dm-only">Initiative:</label>
                    <input type="number" id="token-init" name="token-init" class="dm-only" value="0">
                    <label for="token-ac" class="dm-only">AC:</label>
                    <input type="number" id="token-ac" name="token-ac" class="dm-only" value="0" min="0">
					<!-- Additions for Vision/Light -->
					<label for="token-sight-radius" class="dm-only">Sight Radius (cells):</label>
					<input type="number" id="token-sight-radius" name="token-sight-radius" class="dm-only" value="30" min="0">

					<label for="isLightSource" class="dm-only">Is Light Source:</label>
					<input type="checkbox" id="isLightSource" name="isLightSource" class="dm-only">
					
					<!-- This div contains the bright/dim range inputs and is hidden/shown by the script -->
					<div class="light-range-inputs dm-only" style="display: none; flex-direction: column; gap: 6px; padding-left: 10px; border-left: 1px solid #ccc;">
						<label for="token-bright-range">Bright Range (cells):</label>
						<input type="number" id="token-bright-range" name="token-bright-range" value="0" min="0">
						<label for="token-dim-range">Dim Range (cells, total):</label>
						<input type="number" id="token-dim-range" name="token-dim-range" value="0" min="0">
					</div>
                    <label for="isMinion">Is Minion:</label>
                    <input type="checkbox" id="isMinion" name="isMinion">
                    <button type="submit">Add Token</button>
                </form>
            </details>

            <details>
                <summary>Player Tokens</summary>
                <form id="player-token-form">
                    <label for="player-token-name">Token Name:</label>
                    <input type="text" id="player-token-name" name="player-token-name" value="">
                    <label for="player-token-image">Token Image URL:</label>
                    <input type="text" id="player-token-image" name="player-token-image" value="">
                    <label for="player-token-image-file">Or Upload Image:</label>
                    <input type="file" id="player-token-image-file" name="player-token-image-file" accept="image/*">
                    <label for="player-token-color">Token Color:</label>
                    <input type="text" id="player-token-color" name="player-token-color">
                    <label for="player-token-size">Token Size:</label>
                    <select id="player-token-size" name="player-token-size">
                        <option value="1">1x1 (Medium)</option>
                        <option value="2">2x2 (Large)</option>
                    </select>
                    <label for="player-token-rotation">Token Rotation (degrees):</label>
                    <input type="number" id="player-token-rotation" name="player-token-rotation" value="0" min="0" max="360" step="1">
                    <label for="playerIsMinion">Is Minion:</label>
                    <input type="checkbox" id="playerIsMinion" name="playerIsMinion">
                    <button type="submit">Add Player Token</button>
                </form>
            </details>

            <details class="dm-controls">
                <summary>Background</summary>
                <form id="background-form">
                    <label for="background-image-url">Background Image URL:</label>
                    <input type="text" id="background-image-url" name="background-image-url">
                    <label for="background-image-file">Or Upload Image:</label>
                    <input type="file" id="background-image-file" name="background-image-file" accept="image/*">
                    <div style="display: flex; gap: 4px;">
                        <button type="button" id="load-background-button">Load BG</button>
                        <button type="button" id="clear-background-button">Clear BG</button>
                    </div>
                </form>
            </details>

            <details class="dm-controls">
                <summary>Scene Size</summary>
                <div>
                    <label for="grid-size-select">Scene Size:</label>      
					<select id="grid-size-select">
						<option value="micro">Micro (20x15)</option>
						<option value="small" selected>Small (40x30)</option>
						<option value="medium">Medium (70x40)</option>
						<option value="large">Large (100x55)</option>
						<option value="extra-large">Extra Large (140x70)</option>
						<option value="small-portrait">Small Portrait (30x40)</option> // Add this
						<option value="medium-portrait">Medium Portrait (40x70)</option> // Add this
						<option value="large-portrait">Large Portrait (55x100)</option> // Add this
						<option value="extra-large-portrait">Extra Large Portrait (70x140)</option> // Add this
					</select>
						
                </div>
            </details>

            <details id="instructions-section">
                <summary>Instructions</summary>
                <div id="instructions">
                    <p><strong>Instructions:</strong></p>
                    <ul>
                        <li>DM: Add tokens/background, draw walls, manage scene.</li>
                        <li>DM: Set Max HP and Current HP for tokens; lower HP adds a red tint.</li>
                        <li>Players: Add/move your own tokens.</li>
                        <li>Tap/drag tokens to move (Interact mode).</li>
                        <li>Long-press tokens to rotate (or remove/edit for DM).</li>
                        <li>Pinch to zoom, drag to pan.</li>
                        <li>DM: Draw/Erase Walls in respective modes.</li>
                        <li>DM: Save state locally, download, or import for transfer.</li>
                        <li>Reset View to center grid.</li>
                    </ul>
                </div>
            </details>

            <div id="server-address-display">
                <strong>Server Address:</strong><br>
                <!-- Addresses will be populated here by the script -->
            </div>


            <div id="close-controls-button">X</div>
        </div>
    </div>
    <button id="show-controls-button">Show Controls</button>

    <!-- Grid Container -->
    <div id="grid-container">
        <canvas id="grid"></canvas>
    </div>

     <!-- Socket.IO Client Library - Load Relative -->
    <script src="/socket.io/socket.io.js"></script>

    <script>
		// Ensure the entire script runs after the DOM is ready
		document.addEventListener('DOMContentLoaded', () => {
			// Check if running in Electron via preload script
			const isElectron = typeof window.electronAPI !== 'undefined';
			console.log('isElectron:', isElectron);

			let serverUrl = ''; // Will be determined dynamically
			let socket = null; // Initialize socket variable
			let username = null;
			let currentRole = null;

			// Suppress Autofill errors to clean up console
			console.error = (function (originalError) {
				return function (...args) {
					if (typeof args[0] === 'string' && args[0].includes('Autofill')) {
						return;
					}
					originalError.apply(console, args);
				};
			})(console.error);

			// Load Socket.IO client library dynamically
			function loadSocketIO() {
				return new Promise((resolve, reject) => {
					if (typeof io !== 'undefined') {
						console.log('Socket.IO already loaded');
						resolve();
						return;
					}

					// Socket.IO client is served by the server itself at /socket.io/socket.io.js
					// This ensures we get the correct version matching the server.
					const socketIoUrl = `${window.location.protocol}//${window.location.host}/socket.io/socket.io.js`;
					const script = document.createElement('script');
					script.src = socketIoUrl;
					script.async = true;
					script.onload = () => {
						console.log('Socket.IO client library loaded');
						resolve();
					};
					script.onerror = () => {
						console.error('Failed to load Socket.IO client library from', socketIoUrl);
						showNotification('Failed to load Socket.IO. Please refresh the page.', true);
						reject(new Error('Failed to load Socket.IO'));
					};
					document.head.appendChild(script);
				});
			}


			async function determineServerUrl() {
				const serverAddressDisplay = document.getElementById('server-address-display'); // Get the element here

				// Always ensure socket.io is loaded before attempting connection or IPC
				try {
					await loadSocketIO();
				} catch (err) {
					console.error("Cannot proceed without Socket.IO:", err);
					if (serverAddressDisplay) {
                         serverAddressDisplay.innerHTML = '<strong>Server Address:</strong><br>Failed to load Socket.IO client library.';
                    }
					return; // Stop execution if socket.io fails to load
				}


				if (isElectron) {
					try {
                        // Call the IPC handler to get addresses
						const addressInfo = await window.electronAPI.getServerAddress();
						console.log('Received address info from main:', addressInfo);

                        // Use the localhost address for the Electron window's connection URL
						serverUrl = addressInfo.local; // Connect to localhost from within Electron

                        // Update the display element using the received info
						if (serverAddressDisplay) {
                             let html = '<strong>Server Addresses:</strong><br>'; // Use plural
                             // Always show localhost address for debugging/direct access
                             html += `Local: <span id="localhost-address-text">${addressInfo.local}</span>`;

                             // Check for *any* non-local addresses first
                             if (addressInfo.allLan && addressInfo.allLan.length > 0) {
                                  // Show primary LAN if it's distinct and preferred
                                  if (addressInfo.primaryLan && !addressInfo.primaryLan.includes('127.0.0.1') && addressInfo.primaryLan !== addressInfo.local) { // Ensure it's a public/LAN IP and different from localhost
                                      html += `<br>Network: <span id="primary-lan-address-text">${addressInfo.primaryLan}</span>`;
                                      // Add helper text below the preferred one
                                       html += `<br><span style="font-size: 0.9em;">(Share this with players on your network)</span>`;
                                  } else {
                                       html += `<br>Network: <span id="lan-address-text">No primary LAN address found</span>`;
                                        html += `<br><span style="font-size: 0.9em;">(Check network connection/firewall, or try other IPs below)</span>`;
                                  }

                                  // List *other* non-local addresses if there are more than the primary one (or if primary was 127.0.0.1/localhost)
                                  const otherLanAddresses = addressInfo.allLan.filter(addr => addr !== addressInfo.primaryLan && addr !== addressInfo.local);
                                  if (otherLanAddresses.length > 0) {
                                       html += `<br><span style="font-size: 0.9em;">(Other network IPs: ${otherLanAddresses.map(addr => addr.replace(/^https?:\/\//, '').replace(/:\d+$/, '')).join(', ')})</span>`;
                                  }

                             } else {
                                 // No non-local interfaces found at all
                                  html += `<br>Network: <span id="lan-address-text">No network interfaces found (check connection)</span>`;
                             }

                             serverAddressDisplay.innerHTML = html;

                        } else {
                            console.warn('Server Address display element not found.');
                        }

					} catch (error) {
						console.error('Error getting server address from main process:', error);
						// Fallback connection URL if IPC fails (shouldn't happen if preload works)
						// Note: config is not available in renderer unless exposed, using hardcoded default port
						const fallbackPort = 4000; // Assume default port if config is not available
						serverUrl = `http://localhost:${fallbackPort}`;
                        // Update display on error
						if (serverAddressDisplay) {
							serverAddressDisplay.innerHTML = '<strong>Server Address:</strong><br>';
							serverAddressDisplay.innerHTML += '<span id="lan-address-text">Error retrieving network addresses</span>';
							serverAddressDisplay.innerHTML += `<br>Localhost: ${serverUrl}`;
						} else {
                             console.warn('Server Address display element not found during error handling.');
                        }
					}
				} else {
                    // This section is for standard browser access (outside of Electron)
                    // The connection URL is simply the origin the page was loaded from.
					serverUrl = `${window.location.protocol}//${window.location.host}`;

					if (serverAddressDisplay) {
						serverAddressDisplay.innerHTML = '<strong>Connected to:</strong><br>' + serverUrl;
					}
				}

				console.log('Determined Server URL for client connection:', serverUrl);
				initializeSocket(serverUrl); // Initialize socket using the determined serverUrl
			}


			function initializeSocket(url) {
				if (typeof io === 'undefined') {
					console.error('Socket.IO client library not available.');
					showNotification('Error: Cannot connect to server (Socket.IO missing). Please reload.', true);
					return;
				}

				console.log(`Attempting to connect to Socket.IO server at: ${url}`);

				socket = io(url, {
					reconnection: true,
					reconnectionAttempts: 5,
					reconnectionDelay: 1000,
					reconnectionDelayMax: 5000,
					timeout: 20000,
					transports: ['websocket', 'polling'],
					query: { clientType: isElectron ? 'electron' : 'browser' }
				});

				// Socket event handlers
				socket.on('connect', () => {
					console.log('Socket connected:', socket.id, 'to URL:', url);
					showNotification('Connected to server!');
					document.getElementById('loginButton').disabled = false;
					document.getElementById('loginButton').textContent = 'Join';
					initializeDarkMode();
					resizeCanvas(); // Ensure canvas size is set on connect
				});

				socket.on('connect_error', (err) => {
					console.error('Socket connection error:', err.message, (err.cause ? `Cause: ${err.cause}` : ''));
					let errorMsg = 'Connection error. Trying to reconnect...';
					if (err.message.includes('xhr poll error') || err.message.includes('websocket error')) {
						errorMsg = 'Network error connecting to server. Retrying...';
					} else if (err.message === 'timeout') {
						errorMsg = 'Connection timed out. Retrying...';
					} else if (err.message.includes('Not allowed by CORS')) {
                        errorMsg = 'Connection blocked by CORS. Check server configuration.';
                    }
					showNotification(errorMsg, true);
					document.getElementById('loginButton').disabled = true;
					document.getElementById('loginButton').textContent = 'Connecting...';
					// Keep login screen hidden if already logged in, show if not
					if (!username || !currentRole) {
						document.getElementById('loginScreen').classList.remove('hidden');
					}
				});

				socket.on('disconnect', (reason) => {
					console.error('Socket disconnected:', reason);
					let msg = 'Disconnected from server.';
					if (reason === 'io server disconnect') {
						msg = 'Server closed the connection.';
					} else if (reason === 'io client disconnect') {
						msg = 'You disconnected.';
					} else {
						msg = 'Lost connection to server. Attempting to reconnect...';
					}
					if (reason !== 'io client disconnect') {
						showNotification(msg, true);
					}
					document.getElementById('loginButton').disabled = true;
					document.getElementById('loginButton').textContent = 'Disconnected';
					// Always show login screen on disconnect
					document.getElementById('loginScreen').classList.remove('hidden');
					document.body.className = ''; // Clear role class
					// Clear current user/role state on disconnect
					username = null;
					currentRole = null;

				});

				socket.on('reconnect', (attempt) => {
					console.log('Reconnected to server on attempt:', attempt);
					showNotification('Reconnected to server!');
					// Attempt to re-login with stored credentials
					if (username && currentRole) {
						console.log('Attempting to re-login after reconnect...');
						socket.emit('login', { username, role: currentRole });
					} else {
						// If no stored credentials, ensure login screen is visible
						document.getElementById('loginScreen').classList.remove('hidden');
					}
                    // Re-enable login button as reconnection is managed by socket.io
					document.getElementById('loginButton').disabled = false;
					document.getElementById('loginButton').textContent = 'Join';
				});

				socket.on('reconnect_attempt', (attempt) => {
					console.log('Reconnect attempt:', attempt);
					// Optional: Show reconnect attempt notification
					// showNotification(`Connection attempt ${attempt}...`, false);
					document.getElementById('loginButton').textContent = `Reconnecting (${attempt})...`;
				});

				socket.on('reconnect_failed', () => {
					console.error('Reconnection failed after multiple attempts');
					showNotification('Failed to reconnect. Please check the server or refresh the page.', true);
					document.getElementById('loginButton').disabled = true;
					document.getElementById('loginButton').textContent = 'Reconnect Failed';
					// Ensure login screen is visible
					document.getElementById('loginScreen').classList.remove('hidden');
				});

				socket.on('ping', () => {
					// console.log('Ping sent to server'); // Keep console clean
				});

				socket.on('pong', (latency) => {
					// console.log('Pong received, latency:', latency, 'ms'); // Keep console clean
				});

				// Game state and UI logic
				let pendingWallChanges = {};
				let tokensData = [];
				let backgroundImage = null;
				let backgroundImageUrl = '';
				let scale = 1;
				let panX = 0;
				let panY = 0;
				let walls = [];
				let isGridVisible = true; // Controls drawing grid lines, not visibility mask
				const canvas = document.getElementById('grid');
				const ctx = canvas.getContext('2d');
				const gridSize = 25; // Pixels per grid cell
				let draggedToken = null;
				let draggedTokenIndex = -1;
				let offsetX, offsetY;
				let isPanning = false;
				let isDrawing = false; // For walls
				let startX, startY; // For pan/draw start
				let currentInteractionMode = 'interact';
				let isLoading = false; // Flag to prevent interaction while loading state
				let hoveredTokenIndex = -1;
				let longPressTimeout = null;
				let longPressStartX = 0;
				let longPressStartY = 0;
				let isLongPressing = false;
				let pinchStartDistance = 0;
				let pinchStartScale = 1;
				let pinchStartCenterX = 0;
				let pinchStartCenterY = 0;
				let isContextMenuOpen = false;
				let lastDrawTime = 0;
				let glowFrame = 0; // Used for token glow animation
				let drawPending = false; // Flag to limit redraws

				// --- Visibility Variables ---
                // These Sets store string keys "{x},{y}"
				let brightLightCells = new Set(); // Cells visible in bright light from light sources
                let dimLightCells = new Set();    // Cells visible in dim light from light sources (but not bright)
                let playerVisionCells = new Set(); // Cells visible by player's own inherent vision (e.g., darkvision)
                let visibilityMaskCanvas = document.createElement('canvas'); // Offscreen canvas for mask
                let visibilityMaskCtx = visibilityMaskCanvas.getContext('2d');
                let maskDirty = true; // Flag to indicate if the mask needs recalculation

				const gridContainer = document.getElementById('grid-container');
				const addTokenForm = document.getElementById('add-token-form');
				const playerTokenForm = document.getElementById('player-token-form');
				const darkModeToggle = document.getElementById('dark-mode-toggle');
				const controlsContainer = document.getElementById('controls-container');
				const instructionsDiv = document.getElementById('instructions');
				const showControlsButton = document.getElementById('show-controls-button');
				const closeControlsButton = document.getElementById('close-controls-button');
				const controlsWrapper = document.getElementById('controls-wrapper');
				const gridSizeSelect = document.getElementById('grid-size-select');
				const drawWallButton = document.getElementById('draw-wall-button');
				const eraseWallButton = document.getElementById('erase-wall-button');
				const interactButton = document.getElementById('interact-button');
				const toggleGridButton = document.getElementById('toggle-grid-button');
				const resetViewButton = document.getElementById('reset-view-button');
				const backgroundForm = document.getElementById('background-form');
				const backgroundImageUrlInput = document.getElementById('background-image-url');
				const backgroundImageFileInput = document.getElementById('background-image-file');
				const loadBackgroundButton = document.getElementById('load-background-button');
				const clearBackgroundButton = document.getElementById('clear-background-button');
				const saveStateButton = document.getElementById('save-state-button');
				const downloadStateButton = document.getElementById('download-state-button');
				const importStateButton = document.getElementById('import-state-button');
				const importStateFile = document.getElementById('import-state-file');
				const notificationDiv = document.getElementById('notification');
                const serverAddressDisplay = document.getElementById('server-address-display');


				const gridSizeOptions = {
					micro: { width: 20, height: 15 },
					small: { width: 40, height: 30 }, // Landscape
					medium: { width: 70, height: 40 },
					large: { width: 100, height: 55 },
					'extra-large': { width: 140, height: 70 },
                    // Portrait options:
                    'small-portrait': { width: 30, height: 40 },
                    'medium-portrait': { width: 40, height: 70 },
                    'large-portrait': { width: 55, height: 100 },
                    'extra-large-portrait': { width: 70, height: 140 },
				};

				let currentGridWidthCells = gridSizeOptions.small.width;
				let currentGridHeightCells = gridSizeOptions.small.height;

				function showNotification(message, isError = false) {
					notificationDiv.textContent = message;
					notificationDiv.classList.toggle('error', isError);
					notificationDiv.style.display = 'block';
					setTimeout(() => {
						notificationDiv.style.display = 'none';
						notificationDiv.classList.remove('error');
					}, 3000);
				}

				function normalizeWalls(wallsData, width, height) {
					// Ensure width and height are positive integers
					const validWidth = Math.max(1, Math.floor(width || 1));
					const validHeight = Math.max(1, Math.floor(height || 1));

					// Create a new 2D array filled with 0s for the target size
					const normalized = Array(validHeight).fill(null).map(() => Array(validWidth).fill(0));

					if (wallsData && Array.isArray(wallsData)) {
						// Copy existing wall data up to the bounds of the new size
						for (let y = 0; y < Math.min(validHeight, wallsData.length); y++) {
							if (wallsData[y] && Array.isArray(wallsData[y])) {
								for (let x = 0; x < Math.min(validWidth, wallsData[y].length); x++) {
									// Ensure the value is strictly 1, otherwise default to 0
									normalized[y][x] = wallsData[y][x] === 1 ? 1 : 0;
								}
							}
							// If a row is invalid or missing, the corresponding row in 'normalized' remains 0s
						}
					} else if (wallsData) {
						// If wallsData exists but isn't an array
						console.warn("normalizeWalls: wallsData is not an array. Initializing empty walls.");
					}
					// If wallsData is null/undefined, the array initialized with 0s is returned

					return normalized;
				}


				function initializeDarkMode() {
					const isDarkMode = localStorage.getItem('darkMode') === 'true';
					document.body.classList.toggle('dark-mode', isDarkMode);
					darkModeToggle.textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
					updateDarkModeStyles(isDarkMode);
					// drawGrid(); // No need to draw here, init or resizeCanvas will draw
				}

				function updateDarkModeStyles(isDarkMode) {
					document.querySelectorAll('#add-token-form, #player-token-form, #background-form, #instructions, #controls-container, #loginScreen, #show-controls-button, #notification, #server-address-display').forEach(el => {
						el.classList.toggle('dark-mode', isDarkMode);
					});
					canvas.classList.toggle('dark-mode', isDarkMode);
				}

				function imageToDataUrl(file, callback) {
					if (!file) {
						callback(null);
						return;
					}
					const reader = new FileReader();
					reader.onload = () => callback(reader.result);
					reader.onerror = () => {
						console.error('Failed to read file:', file.name);
						callback(null);
					};
					reader.readAsDataURL(file);
				}

				function preloadTokenImage(tokenData) {
					if (tokenData.imageUrl) {
						const img = new Image();
						img.src = tokenData.imageUrl;
						img.onload = () => {
							tokenData.imageObj = img;
							// Trigger mask recalculation if this token belongs to the player or is a light source
							if (currentRole === 'player' && (tokenData.owner === username || tokenData.isLightSource)) {
								maskDirty = true;
							}
							drawGrid(); // Redraw once image is loaded
						};
						img.onerror = () => {
							console.warn(`Failed to load token image: ${tokenData.imageUrl}`);
							tokenData.imageObj = null;
							drawGrid(); // Redraw even on error
						};
					} else {
						tokenData.imageObj = null;
					}
				}

				function resizeCanvas() {
					canvas.width = document.documentElement.clientWidth;
					canvas.height = document.documentElement.clientHeight;
                    // The mask canvas size needs to match the total grid pixel size
                    visibilityMaskCanvas.width = currentGridWidthCells * gridSize;
                    visibilityMaskCanvas.height = currentGridHeightCells * gridSize;
                    maskDirty = true; // Mask size changed, needs recalculation
					drawGrid(); // Redraw after resize
				}

				function loadBackgroundImage(url) {
					if (!url) {
						backgroundImage = null;
						backgroundImageUrl = '';
						drawGrid();
						return;
					}

					const img = new Image();
					img.onload = () => {
						backgroundImage = img;
						backgroundImageUrl = url;
						if (url && !url.startsWith('data:')) {
							backgroundImageUrlInput.value = url;
						} else {
							backgroundImageUrlInput.value = ''; // Clear URL field if it's a data URL
						}
						drawGrid();
					};
					img.onerror = () => {
						console.error(`Failed to load background image from: ${url}`);
						showNotification('Failed to load background image.', true);
						backgroundImage = null;
						backgroundImageUrl = '';
						drawGrid();
					};
					img.src = url;
				}

				// --- Basic Line of Sight Algorithm ---
                function isLOSClear(x0, y0, x1, y1, walls, gridWidth, gridHeight) {
                    // Check boundaries
                    if (x0 < 0 || x0 >= gridWidth || y0 < 0 || y0 >= gridHeight ||
                        x1 < 0 || x1 >= gridWidth || y1 < 0 || y1 >= gridHeight) {
                        return false; // Should not happen if iterating within grid, but safety check
                    }
                    // Starting point is never blocked
                    if (x0 === x1 && y0 === y1) return true;

                    // Implement a simple stepping algorithm (like Bresenham's on grid cells)
                    const dx = Math.abs(x1 - x0);
                    const dy = Math.abs(y1 - y0);
                    const sx = (x0 < x1) ? 1 : -1;
                    const sy = (y0 < y1) ? 1 : -1;
                    let err = dx - dy;

                    let x = x0;
                    let y = y0;

                    while (!(x === x1 && y === y1)) {
                        // Calculate next step
                        const e2 = 2 * err;
                        if (e2 > -dy) {
                            err -= dy;
                            x += sx;
                        }
                        if (e2 < dx) {
                            err += dx;
                            y += sy;
                        }

                         // Check the cell we just stepped INTO (excluding the origin cell)
                         if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                            // If the cell contains a wall, the line of sight is blocked
                            if (walls[y] && walls[y][x] === 1) {
                                return false; // Blocked by a wall
                            }
                         }
                         // The loop continues only if the cell wasn't blocked, stepping towards the target
                    }

                    return true; // Reached the target cell without hitting a wall
                }


                // --- Calculate Visible Cells (Modified for Layered Light/Vision) ---
                function calculateVisibleCells() {
                    // Only calculate for players
                    if (currentRole === 'dm') {
                        // DM sees everything - handled in drawGrid by skipping mask
                        brightLightCells.clear();
                        dimLightCells.clear();
                        playerVisionCells.clear();
                        // No mask needed for DM, maskDirty will be set false in drawGrid for DM
                        return;
                    }

                    // Clear previous visibility sets
                    brightLightCells.clear();
                    dimLightCells.clear();
                    playerVisionCells.clear(); // Clear player inherent vision set

                    // Temporary sets to manage overlaps easily before finalizing
                    const potentialBrightCells = new Set();
                    const potentialDimCells = new Set();
                    const potentialPlayerInherentCells = new Set(); // Temporary set for player's raw inherent vision


                    const lightSources = tokensData.filter(token => token.isLightSource);
                    const playerTokens = tokensData.filter(token =>
                        token.owner === username || (token.isMinion && token.parentOwner === username)
                    );

                    const gridWidth = currentGridWidthCells;
                    const gridHeight = currentGridHeightCells;

                    // 1. Calculate light source visibility (Bright and Dim ranges)
                    lightSources.forEach(sourceToken => {
                         const sx = sourceToken.x;
                         const sy = sourceToken.y;
                         // Use || 0 for safety, ensure dimRange is at least brightRange
                         const brightRange = sourceToken.brightRange || 0;
                         const dimRange = Math.max(brightRange, sourceToken.dimRange || 0); // Dim range must be >= bright range


                         if (dimRange <= 0) return; // Light source doesn't illuminate

                         // Check cells within the total dim light radius bounding box (inclusive)
                         const startCheckX = Math.max(0, sx - dimRange);
                         const endCheckX = Math.min(gridWidth - 1, sx + dimRange);
                         const startCheckY = Math.max(0, sy - dimRange);
                         const endCheckY = Math.min(gridHeight - 1, sy + dimRange);


                         for (let y = startCheckY; y <= endCheckY; y++) {
                             for (let x = startCheckX; x <= endCheckX; x++) {
                                 // Using Chebyshev distance (max of horizontal/vertical distance) for radius
                                 const dist = Math.max(Math.abs(x - sx), Math.abs(y - sy));

                                 if (dist > dimRange) {
                                     continue; // Outside total light radius
                                 }

                                 // Check Line of Sight from the light source's cell center to the target cell's center
                                 // isLOSClear correctly checks if a wall cell is on the path.
                                 if (isLOSClear(sx, sy, x, y, walls, gridWidth, gridHeight)) {
                                     const cellKey = `${x},${y}`;
                                     if (dist <= brightRange) {
                                         potentialBrightCells.add(cellKey);
                                     } else { // dist > brightRange && dist <= dimRange
                                         potentialDimCells.add(cellKey);
                                     }
                                 }
                             }
                         }
                    });


                    // 2. Calculate player token inherent vision (e.g., darkvision, normal sight without external light)
                    // This vision determines *which* cells a player has vision over, but doesn't dictate
                    // the *visual appearance* unless combined with light sources.
                     playerTokens.forEach(playerToken => {
                         const px = playerToken.x;
                         const py = playerToken.y;
                         const sightRadius = playerToken.sightRadius || 0; // Inherent sight radius

                         if (sightRadius <= 0) return; // Token cannot see inherently

                         // Check cells within the token's inherent sight radius bounding box (inclusive)
                         const startCheckX = Math.max(0, px - sightRadius);
                         const endCheckX = Math.min(gridWidth - 1, px + sightRadius);
                         const startCheckY = Math.max(0, py - sightRadius);
                         const endCheckY = Math.min(gridHeight - 1, py + sightRadius);

                         for (let y = startCheckY; y <= endCheckY; y++) {
                              for (let x = startCheckX; x <= endCheckX; x++) {
                                   // Using Chebyshev distance
                                   const dist = Math.max(Math.abs(x - px), Math.abs(y - py));

                                   if (dist > sightRadius) {
                                       continue; // Outside inherent sight radius
                                   }

                                   // Check Line of Sight from the player token's cell center to the target cell's center
                                   if (isLOSClear(px, py, x, y, walls, gridWidth, gridHeight)) {
                                        potentialPlayerInherentCells.add(`${x},${y}`);
                                   }
                              }
                         }
                     });


                    // 3. Combine and finalize visibility sets based on light precedence
                    // Bright light areas are fully visible (0% mask)
                    brightLightCells = potentialBrightCells;

                    // Dim light includes cells potentially in dim light *not* already in bright light
                    dimLightCells = new Set(); // Clear previous dim set
                     potentialDimCells.forEach(cellKey => {
                         if (!brightLightCells.has(cellKey)) { // Must NOT be in bright light
                              dimLightCells.add(cellKey);
                         }
                     });

                    // Player vision includes cells potentially seen by player sight *not* in bright or dim light
                    // These cells will be discernable (token names visible), but visually remain fog unless overridden by owned token location.
                    playerVisionCells = new Set(); // Clear previous player vision set
                    potentialPlayerInherentCells.forEach(cellKey => {
                         if (!brightLightCells.has(cellKey) && !dimLightCells.has(cellKey)) {
                             playerVisionCells.add(cellKey);
                         }
                    });

                    // Important: The combined set for general visibility checks (like token name display)
                    // is Bright + Dim + Player Vision.
                    // This ensures tokens in dark areas seen by darkvision still get their names displayed.
                    // We don't store this explicitly as a set here, but functions like isCellKnowable
                    // check across all three sets.

                     maskDirty = true; // Mask needs to be rebuilt based on new visibility sets
                }

                // --- Build the Visibility Mask Canvas (Corrected Logic & Fixed Typos) ---
                // This function creates a mask canvas where each pixel's alpha determines visual appearance:
                // alpha = 0   -> Fully Visible (Bright Light OR Player's OWN Token Location)
                // alpha = 0.6 -> Dimmed (Dim Light)
                // alpha = 1   -> Solid Black Fog (Player Inherent Vision ALONE OR Not Visible at all)
                function buildVisibilityMask() {
                     if (!maskDirty) return; // Only rebuild if necessary

                     const gridPixelWidth = currentGridWidthCells * gridSize;
                     const gridPixelHeight = currentGridHeightCells * gridSize; // FIXED: Changed 'gridHeight' to 'gridSize'

                     visibilityMaskCanvas.width = gridPixelWidth;
                     visibilityMaskCanvas.height = gridPixelHeight;
                     visibilityMaskCtx.clearRect(0, 0, gridPixelWidth, gridPixelHeight); // Start with a fully transparent canvas

                     const dimmingOpacity = 0.6; // Opacity for the dim areas (60% black fog overlay)

                     // Get player-owned tokens for the override check
                     const playerTokens = tokensData.filter(token =>
                         token.owner === username || (token.isMinion && token.parentOwner === username)
                     );


                     // Iterate through all grid cells and draw the appropriate mask pixel
                     for (let y = 0; y < currentGridHeightCells; y++) {
                         for (let x = 0; x < currentGridWidthCells; x++) {
                             const cellKey = `${x},${y}`;
                             let maskOpacity = 1; // Default to full fog (opaque black)

                             // Determine base opacity based on light/vision precedence
                             // Bright Light > Dim Light > Full Fog (for anything else, including Player Vision Alone)
                             if (brightLightCells.has(cellKey)) {
                                 maskOpacity = 0; // Fully transparent in bright light
                             }
                             else if (dimLightCells.has(cellKey)) {
                                 maskOpacity = dimmingOpacity; // Semi-transparent in dim light
                             }
                             // Note: If the cell is only in playerVisionCells, maskOpacity remains the default 1 (solid fog).


                             // Override mask opacity if this cell is occupied by the CURRENT PLAYER's token(s)
                             // This ensures the owned token's space is always fully clear visually.
                             const isOwnedPlayerTokenLocation = playerTokens.some(token => {
                                 const tokenSize = token.size || 1;
                                 // Check all cells the token occupies
                                 for (let dy = 0; dy < tokenSize; dy++) {
                                     for (let dx = 0; dx < tokenSize; dx++) {
                                         if (token.x + dx === x && token.y + dy === y) {
                                             return true; // Cell is part of an owned token's space
                                         }
                                     }
                                 }
                                 return false;
                             });

                             if (isOwnedPlayerTokenLocation) {
                                  maskOpacity = 0; // Make player's *own* token squares fully clear, regardless of other lighting/vision
                             }

                             // Draw the mask pixel with the determined opacity (0=clear, dimmingOpacity=dim, 1=fog)
                             visibilityMaskCtx.fillStyle = `rgba(0, 0, 0, ${maskOpacity})`;
                             visibilityMaskCtx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                         }
                     }

                     maskDirty = false; // Mask is now up-to-date
                }


				function drawGrid() {
					// Removed the optimization that skipped drawing for players when mask wasn't dirty
					// This ensures the animation frame updates continuously.

					if (drawPending) return;
					drawPending = true;

					requestAnimationFrame(() => {
						const now = performance.now();
						lastDrawTime = now; // Update last draw time regardless

						glowFrame = now / 1000; // Update glow animation frame

						ctx.clearRect(0, 0, canvas.width, canvas.height);
						ctx.save();
						ctx.translate(panX, panY);
						ctx.scale(scale, scale);

                        const gridPixelWidth = currentGridWidthCells * gridSize;
                        const gridPixelHeight = currentGridHeightCells * gridSize;

						// Draw background image
						if (backgroundImage && backgroundImage.complete && backgroundImage.naturalWidth !== 0) {
							const gridAspectRatio = gridPixelWidth / gridPixelHeight;
							const imageAspectRatio = backgroundImage.width / backgroundImage.height;

							let drawWidth, drawHeight, offsetX, offsetY;
							// Calculate dimensions to cover the entire grid area while maintaining aspect ratio
                            if (imageAspectRatio > gridAspectRatio) {
                                // Image is wider than grid, match grid height
                                drawHeight = gridPixelHeight;
                                drawWidth = drawHeight * imageAspectRatio;
                            } else {
                                // Image is taller than grid, match grid width
                                drawWidth = gridPixelWidth;
                                drawHeight = drawWidth / imageAspectRatio;
                            }
                            // Center the image within the grid area
                            offsetX = (gridPixelWidth - drawWidth) / 2;
                            offsetY = (gridPixelHeight - drawHeight) / 2;

							ctx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
						}

						// --- Draw Grid Lines (Optional based on isGridVisible) ---
                        // Draw grid lines BEFORE walls/tokens/mask so they are visible underneath if visibility allows
						if (isGridVisible) {
							const gridColor = document.body.classList.contains('dark-mode') ? 'rgba(85, 85, 85, 0.7)' : 'rgba(204, 204, 204, 0.7)';
							ctx.strokeStyle = gridColor;
							ctx.lineWidth = 1 / scale; // Scale line width with zoom

							for (let i = 0; i <= currentGridWidthCells; i++) {
								const x = i * gridSize;
								ctx.beginPath();
								ctx.moveTo(x, 0);
								ctx.lineTo(x, gridPixelHeight);
								ctx.stroke();
							}
							for (let i = 0; i <= currentGridHeightCells; i++) {
								const y = i * gridSize;
								ctx.beginPath();
								ctx.moveTo(0, y);
								ctx.lineTo(gridPixelWidth, y);
								ctx.stroke();
							}
						}

                        // --- Draw Walls ---
                        // Draw walls BEFORE tokens.
                        // For players, these will be hidden by the mask unless they are in a visible cell.
                        let wallColor = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)';
                        ctx.fillStyle = wallColor;
                        for (let y = 0; y < currentGridHeightCells; y++) {
                            for (let x = 0; x < currentGridWidthCells; x++) {
                                if (walls[y] && walls[y][x] === 1) {
                                    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                                }
                            }
                        }

						// --- Draw Tokens ---
                        // Tokens are drawn before the visibility mask is applied
						tokensData.forEach((tokenData, index) => {
							ctx.save();
							const tokenSize = tokenData.size || 1;
							const x = tokenData.x * gridSize;
							const y = tokenData.y * gridSize;
							const width = gridSize * tokenSize;
							const height = gridSize * tokenSize;
							const rotation = (tokenData.rotation || 0) * Math.PI / 180;
							const isSelected = index === hoveredTokenIndex || index === draggedTokenIndex;
							let hpPercentage = 1;
							const isLowHealth = tokenData.maxHP > 0 && tokenData.hp !== undefined && tokenData.hp / tokenData.maxHP < 0.25;

							ctx.translate(x + width / 2, y + height / 2);
							ctx.rotate(rotation);

							const drawX = -width / 2;
							const drawY = -height / 2;

							// --- DRAW GLOW EFFECT FIRST (if applicable) ---
							if (isSelected || isLowHealth) {
								const glowStrength = Math.sin(glowFrame * Math.PI * 2) * 0.2 + 0.8;
								const sizeFactor = Math.min(1 / tokenSize, 1);
								const glowMultiplier = 1 + sizeFactor * 0.8; // This multiplier is for blur intensity

								ctx.shadowColor = isSelected
									? (document.body.classList.contains('dark-mode') ? 'rgba(150, 150, 255, 0.8)' : 'rgba(0, 0, 255, 0.6)')
									: 'rgba(255, 50, 50, 0.8)';

								ctx.shadowBlur = 50 * glowStrength * glowMultiplier / scale; // Base blur 50

								// Pulsing scale effect (optional)
								const baseScale = 1.0; // Base size scale is 1 (normal)
								// Increase the multiplier for more noticeable pulse
								const pulseScale = baseScale + (glowStrength * 0.08 * sizeFactor); // Pulse amount scaled by glow strength and size factor, increased multiplier
								ctx.scale(pulseScale, pulseScale); // Apply the pulse scale transform
							


								// Draw a shape purely to generate the blurred shadow *behind* the token
								// We draw with the same color as the shadow.
								ctx.fillStyle = ctx.shadowColor; // Use the shadow color for the shape fill

								if (tokenSize === 1) {
									ctx.beginPath();
									ctx.arc(0, 0, width / 2, 0, Math.PI * 2);
									ctx.fill(); // This will draw a blurred circle
								} else {
									 // Draw a blurred rounded rectangle
									 const radius = width * 0.15;
									 ctx.beginPath();
									 ctx.moveTo(drawX + radius, drawY);
									 ctx.lineTo(drawX + width - radius, drawY);
									 ctx.quadraticCurveTo(drawX + width, drawY, drawX + width, drawY + radius);
									 ctx.lineTo(drawX + width, drawY + height - radius);
									 ctx.quadraticCurveTo(drawX + width, drawY + height, drawX + width - radius, drawY + height);
									 ctx.lineTo(drawX + radius, drawY + height);
									 ctx.quadraticCurveTo(drawX, drawY + height, drawX, drawY + height - radius);
									 ctx.lineTo(drawX, drawY + radius);
									 ctx.quadraticCurveTo(drawX, drawY, drawX + radius, drawY);
									 ctx.closePath();
									 ctx.fill();
								}

								// Important: Clear the shadow properties *before* drawing the token image/color
								ctx.shadowBlur = 0;
								ctx.shadowColor = 'transparent';
							}

							// --- DRAW TOKEN IMAGE/COLOR (ON TOP) ---
							// This part draws the token itself without any shadow effects
							if (tokenSize === 1) {
								ctx.beginPath();
								ctx.arc(0, 0, width / 2, 0, Math.PI * 2);
								ctx.clip(); // Clip for the token image/color/tint
								if (tokenData.imageObj && tokenData.imageObj.complete && tokenData.imageObj.naturalWidth !== 0) {
									ctx.drawImage(tokenData.imageObj, drawX, drawY, width, height);
								} else {
									ctx.fillStyle = tokenData.backgroundColor || 'grey';
									ctx.fill();
								}
							} else {
								const radius = width * 0.15;
								 ctx.beginPath();
								 ctx.moveTo(drawX + radius, drawY);
								 ctx.lineTo(drawX + width - radius, drawY);
								 ctx.quadraticCurveTo(drawX + width, drawY, drawX + width, drawY + radius);
								 ctx.lineTo(drawX + width, drawY + height - radius);
								 ctx.quadraticCurveTo(drawX + width, drawY + height, drawX + width - radius, drawY + height);
								 ctx.lineTo(drawX + radius, drawY + height);
								 ctx.quadraticCurveTo(drawX, drawY + height, drawX, drawY + height - radius);
								 ctx.lineTo(drawX, drawY + radius);
								 ctx.quadraticCurveTo(drawX, drawY, drawX + radius, drawY);
								 ctx.closePath();

								 ctx.save(); // Save state before clipping
								 ctx.clip(); // Clip for the token image/color/tint

								if (tokenData.imageObj && tokenData.imageObj.complete && tokenData.imageObj.naturalWidth !== 0) {
									ctx.drawImage(tokenData.imageObj, drawX, drawY, width, height);
								} else {
									ctx.fillStyle = tokenData.backgroundColor || 'grey';
									ctx.fill();
								}

								 ctx.restore(); // Restore state to remove clipping
							}

							// --- APPLY RED TINT (ON TOP of image/color) ---
							if (tokenData.maxHP > 0 && tokenData.hp !== undefined) {
								 hpPercentage = Math.max(0, Math.min(1, tokenData.hp / tokenData.maxHP));
								 const redTint = 1 - hpPercentage;
								 if (redTint > 0) {
									 ctx.globalCompositeOperation = 'source-atop'; // Draw only where destination already has pixels (the token shape)
									 ctx.fillStyle = `rgba(255, 0, 0, ${redTint * 0.5})`; // Semi-transparent red based on HP
									 // Need to redraw the shape path for the fill operation to work correctly after clip/restore
									 if (tokenSize === 1) {
										 ctx.beginPath();
										 ctx.arc(0, 0, width / 2, 0, Math.PI * 2);
										 ctx.fill();
									 } else {
										 const radius = width * 0.15;
										  ctx.beginPath();
										  ctx.moveTo(drawX + radius, drawY);
										  ctx.lineTo(drawX + width - radius, drawY);
										  ctx.quadraticCurveTo(drawX + width, drawY, drawX + width, drawY + radius);
										  ctx.lineTo(drawX + width, drawY + height - radius);
										  ctx.quadraticCurveTo(drawX + width, drawY + height, drawX + width - radius, drawY + height);
										  ctx.lineTo(drawX + radius, drawY + height);
										  ctx.quadraticCurveTo(drawX, drawY + height, drawX, drawY + height - radius);
										  ctx.lineTo(drawX, drawY + radius);
										  ctx.quadraticCurveTo(drawX, drawY, drawX + radius, drawY);
										  ctx.closePath();
										  ctx.fill(); // Redraw shape for tint fill
									 }
									 ctx.globalCompositeOperation = 'source-over'; // Reset composite mode
								 }
							}


							// --- DRAW SELECTION OUTLINE (ON TOP of everything) ---
							if (isSelected) {
								// Selection outline
								ctx.strokeStyle = document.body.classList.contains('dark-mode') ? 'cyan' : 'blue'; // Use cyan for dark mode highlight
								ctx.lineWidth = 2 / scale; // Scale line width with zoom
								 // Need to redraw the shape path for the stroke operation
								 if (tokenSize === 1) {
									 ctx.beginPath();
									 ctx.arc(0, 0, width / 2, 0, Math.PI * 2);
									 ctx.stroke(); // Draw outline
								 } else {
									 const radius = width * 0.15;
									 ctx.beginPath();
									 ctx.moveTo(drawX + radius, drawY);
									 ctx.lineTo(drawX + width - radius, drawY);
									 ctx.quadraticCurveTo(drawX + width, drawY, drawX + width, drawY + radius);
									 ctx.lineTo(drawX + width, drawY + height - radius);
									 ctx.quadraticCurveTo(drawX + width, drawY + height, drawX + width - radius, drawY + height);
									 ctx.lineTo(drawX + radius, drawY + height);
									 ctx.quadraticCurveTo(drawX, drawY + height, drawX, drawY + height - radius);
									 ctx.lineTo(drawX, drawY + radius);
									 ctx.quadraticCurveTo(drawX, drawY, drawX + radius, drawY);
									 ctx.closePath();
									 ctx.stroke(); // Draw outline
								 }
							}


							ctx.restore(); // Restore translation and rotation

							// No need to clear shadow here anymore as it was cleared earlier in the glow drawing block
							// ctx.shadowBlur = 0;
							// ctx.shadowColor = 'transparent';
						});


						// --- Apply Visibility Mask ---
                        // Only apply mask for players
                        if (currentRole === 'player') {
                             // Recalculate visible cells and build mask if needed
                             if (maskDirty) {
                                 calculateVisibleCells(); // This updates brightLightCells, dimLightCells, playerVisionCells
                                 buildVisibilityMask(); // Builds a mask with varying transparency
                             }

                             // Draw the mask canvas scaled and translated
                             ctx.drawImage(visibilityMaskCanvas, 0, 0, gridPixelWidth, gridPixelHeight);
                        } else {
                             // DM has no mask, but we still need the glow animation loop
                             maskDirty = false; // Ensure maskDirty is false for DM
                        }


						ctx.restore(); // Restore pan and scale

						updateTokenNames(); // Update token names after drawing grid/tokens/mask
						drawPending = false;

						// Continue drawing loop
						requestAnimationFrame(drawGrid); // Request the next frame to keep animation running
					});
				}

                // --- Helper to check if any cell a token occupies is in Bright Light ---
                 function isTokenInBrightLight(token) {
                      const tokenSize = token.size || 1;
                      const gridWidth = currentGridWidthCells;
                      const gridHeight = currentGridHeightCells;
                      for (let dy = 0; dy < tokenSize; dy++) {
                          for (let dx = 0; dx < tokenSize; dx++) {
                              const cellX = token.x + dx;
                              const cellY = token.y + dy;
                              // Check boundaries and if the cell key is in the bright set
                              if (cellX >= 0 && cellX < gridWidth && cellY >= 0 && cellY < gridHeight) {
                                  const cellKey = `${cellX},${cellY}`;
                                  if (brightLightCells.has(cellKey)) {
                                      return true; // Found at least one bright cell
                                  }
                              }
                          }
                      }
                      return false; // No occupied cell is in bright light
                 }


				// --- Helper to check if a cell is visible (knowable) to the current player ---
				// This function determines if a cell is *knowable* (can see tokens/walls there), not its visual brightness.
                // Used for interaction checks and general token knowability.
				function isCellKnowable(x, y) {
					if (currentRole === 'dm') return true; // DM sees all
					const cellKey = `${x},${y}`;
					// A cell is *knowable* if it's in bright, dim, OR player vision areas
					// Player's own squares are also knowable (and visually clear)
					const isOwnedPlayerTokenLocation = tokensData.filter(token =>
                         token.owner === username || (token.isMinion && token.parentOwner === username)
                    ).some(token => {
                        const tokenSize = token.size || 1;
                         for (let dy = 0; dy < tokenSize; dy++) {
                             for (let dx = 0; dx < tokenSize; dx++) {
                                 if (token.x + dx === x && token.y + dy === y) {
                                     return true;
                                 }
                             }
                         }
                         return false;
                    });

					return brightLightCells.has(cellKey) || dimLightCells.has(cellKey) || playerVisionCells.has(cellKey) || isOwnedPlayerTokenLocation;
				}

                // --- Helper to check if any part of a token is knowable ---
                // Used for interaction checks and filtering tokens for drawing/names etc.
                 function isTokenKnowable(token) {
                      if (currentRole === 'dm') return true; // DM sees all tokens
                      const tokenSize = token.size || 1;
                       // An owned token is always considered "knowable" and interactable by its owner
                      if (currentRole === 'player' && (token.owner === username || (token.isMinion && token.parentOwner === username))) {
                         return true;
                      }
                       // Otherwise, check if any cell it occupies is knowable (visible by any light or inherent vision)
                      for (let dy = 0; dy < tokenSize; dy++) {
                          for (let dx = 0; dx < tokenSize; dx++) {
                              if (isCellKnowable(token.x + dx, token.y + dy)) { // Use isCellKnowable here
                                   return true;
                              }
                          }
                      }
                      return false; // No part of the token is in a knowable cell
                 }


				function updateTokenNames() {
					// Remove existing token names
					document.querySelectorAll('.token-name').forEach(el => el.remove());

					// Only show names at sufficient zoom or for hovered/dragged token
					const zoomThreshold = 1.0; // Show all names above this scale
					const minDistance = 40; // Minimum pixel distance between names

                    const visibleNames = [];

					// Always include hovered/dragged token name if it's NAME-ELIGIBLE
					const importantTokenIndex = (hoveredTokenIndex !== -1) ? hoveredTokenIndex : draggedTokenIndex;
					const importantToken = (importantTokenIndex !== -1) ? tokensData[importantTokenIndex] : null;

                    // Determine if the important token's name should be displayed
                    const isImportantTokenNameVisible = importantToken ?
                        (currentRole === 'dm' || // DM sees all names
                         importantToken.owner === username || // Owned tokens' names are always visible to owner
                         (importantToken.isMinion && importantToken.parentOwner === username) || // Owned minions' names visible to parent owner
                         isTokenKnowable(importantToken)) // Also show name if any part is knowable (in bright/dim light or vision)
                        : false;


                    if (importantToken && isImportantTokenNameVisible) {
                         const tokenSize = importantToken.size || 1;
                         // Position name centered horizontally above the token's center X
                         const canvasX_center = (importantToken.x + tokenSize / 2) * gridSize; // Canvas X center of the token
                         const canvasY_top = importantToken.y * gridSize; // Canvas Y top of the token bounding box

                         const screenX_center = canvasX_center * scale + panX;
                         const screenY_top = canvasY_top * scale + panY;

                         visibleNames.push({ tokenData: importantToken, screenX: screenX_center, screenY_top: screenY_top, priority: 2 }); // Store screenX as center, screenY_top as top
                    }


					if (scale >= zoomThreshold) {
						tokensData.forEach(tokenData => { // Iterate through ALL tokens
							// Skip if already added (importantToken)
							if (importantToken && importantToken.id === tokenData.id) return;
							if (!tokenData.name) return; // Skip tokens with no name

                            // Determine if the token's name should be visible for THIS client
                            let isNameVisible = false;
                            if (currentRole === 'dm') {
                                isNameVisible = true; // DM sees all names
                            } else {
                                // Player sees name if owned OR if token is knowable
                                const isOwned = tokenData.owner === username || (tokenData.isMinion && tokenData.parentOwner === username);
                                const isAnyPartKnowable = isTokenKnowable(tokenData); // Check if any part is knowable
                                isNameVisible = isOwned || isAnyPartKnowable; // Show name if owned OR knowable
                            }


							if (isNameVisible) {
                                // Calculate screen position - use token center X and token top Y
                                const tokenSize = tokenData.size || 1;
                                const canvasX_center = (tokenData.x + tokenSize / 2) * gridSize; // Canvas X center of the token
                                const canvasY_top = tokenData.y * gridSize; // Canvas Y top of the token bounding box

                                const screenX_center = canvasX_center * scale + panX;
                                const screenY_top = canvasY_top * scale + panY;

                                // Check for overlap with names already chosen for display
                                // A simpler overlap check based on the token's center distance, scaled by zoom:
                                let canShow = true;
                                for (const visible of visibleNames) {
                                     const dx = screenX_center - visible.screenX;
                                     const dy = screenY_top - visible.screenY_top;
                                     const distance = Math.sqrt(dx * dx + dy * dy);
                                     // Scale the minimum distance based on zoom level so closer tokens are more likely to show names zoomed out
                                     if (distance * scale < minDistance) {
                                         canShow = false;
                                         break;
                                     }
                                }

                                if (canShow) {
                                    visibleNames.push({ tokenData, screenX: screenX_center, screenY_top: screenY_top, priority: 0 }); // Store screenX as center, screenY_top as top
                                }
							}
						});
					}

					// --- CORRECTED SORTING LOGIC ---
                    // Sort the names before creating and appending the divs.
                    // Primary sort: Priority (hovered/dragged on top - zIndex 100 vs 10)
                    // Secondary sort: Screen Y position descending (labels for lower tokens draw on top)
                    // Tertiary sort: Screen X position ascending (labels for lefter tokens draw behind righter)
                    visibleNames.sort((a, b) => {
                        // Primary sort: Priority (hovered/dragged highest)
                        if (b.priority !== a.priority) {
                            return b.priority - a.priority;
                        }
                        // Secondary sort: Screen Y position (descending, so lower elements appear later/on top in DOM)
                        if (b.screenY_top !== a.screenY_top) {
                             return b.screenY_top - a.screenY_top;
                        }
                        // Tertiary sort: Screen X position (ascending, so lefter elements appear earlier/behind)
                         return a.screenX - b.screenX;
                    });


					visibleNames.forEach(({ tokenData, screenX, screenY_top }) => {
						const nameDiv = document.createElement('div');
						nameDiv.classList.add('token-name');
						if (currentRole === 'dm') {
							const hpDisplay = tokenData.maxHP > 0 && tokenData.hp !== undefined ? `${tokenData.hp}/${tokenData.maxHP}` : (tokenData.hp !== undefined ? tokenData.hp : '--/--');
							const initDisplay = tokenData.initiative !== undefined ? tokenData.initiative : '--';
                            const acDisplay = tokenData.ac !== undefined ? tokenData.ac : '--';
							const sightDisplay = `Sight: ${tokenData.sightRadius || 0}`;
                            const lightDisplay = tokenData.isLightSource ? `Light: ${tokenData.brightRange || 0}/${tokenData.dimRange || 0}` : '';
                            // Combine stat line and light line if light source
                            if (lightDisplay) {
                                nameDiv.innerHTML = `${tokenData.name} (HP: ${hpDisplay}, Init: ${initDisplay}, AC: ${acDisplay}) <br> ${lightDisplay}`;
                                nameDiv.style.lineHeight = '1.2'; // Adjust line height for multiple lines
                            } else {
                                nameDiv.textContent = `${tokenData.name} (HP: ${hpDisplay}, Init: ${initDisplay}, AC: ${acDisplay})`;
                            }

						} else {
                            // For players, just show the name (no stats in the name tag)
							nameDiv.textContent = tokenData.name; // This is just the name for players
						}
						nameDiv.dataset.tokenId = tokenData.id;

                        // Append first to measure (necessary to get offsetWidth/offsetHeight)
                        document.body.appendChild(nameDiv);

						// --- CORRECTED POSITIONING LOGIC ---
                        // Set left to the token's screen center X
                         nameDiv.style.left = `${screenX}px`;
                        // Set top to the token's screen top Y minus a small offset.
                        // The CSS transform translate(-50%, -100%) will then correctly
                        // position the name's bottom-center at (screenX, screenY_top - 5).
                         nameDiv.style.top = `${screenY_top - 5}px`; // 5px padding above token


						// Check if this specific nameDiv's token is hovered or dragged based on original index
						const originalIndex = tokensData.findIndex(t => t.id === tokenData.id);
						const isSelected = originalIndex === hoveredTokenIndex || originalIndex === draggedTokenIndex;

						// --- ADD Z-INDEX LOGIC (REMAINS THE SAME) ---
						nameDiv.style.zIndex = '10'; // Base z-index below controls (11)
						if (isSelected) {
							nameDiv.classList.add('hovered'); // Add hover style class
							nameDiv.style.zIndex = '100'; // Bring selected/hovered name to front (above other names)
						} else {
							nameDiv.style.opacity = '0.7'; // Dim non-hovered names
						}
					});
				}

				function getTokenAtPosition(canvasX, canvasY) {
					// Filter tokens to only consider those that are knowable and interactable
                    // Interaction requires ownership/DM role AND knowability (checked by isTokenKnowable)
                    const interactiveTokens = tokensData.filter(token => {
                         // DM can interact with any token regardless of knowability
                         if (currentRole === 'dm') return true;
                         // Player can interact with owned tokens IF they are knowable
                         // The isTokenKnowable check includes an override for owned tokens
                         const isOwner = token.owner === username || (token.isMinion && token.parentOwner === username);
                         return isOwner && isTokenKnowable(token); // isTokenKnowable has the owned-token override
                    });


					for (let i = interactiveTokens.length - 1; i >= 0; i--) {
						const tokenData = interactiveTokens[i];
						const originalIndex = tokensData.findIndex(t => t.id === tokenData.id); // Get original index
						const tokenSize = tokenData.size || 1;
						const tokenPixelWidth = gridSize * tokenSize;
						const tokenPixelHeight = gridSize * tokenSize;
						const tokenX = tokenData.x * gridSize;
						const tokenY = tokenData.y * gridSize;

						// Simple bounding box check first
						if (
							canvasX >= tokenX &&
							canvasX < tokenX + tokenPixelWidth &&
							canvasY >= tokenY &&
							canvasY < tokenY + tokenPixelHeight
						) {
							// The filter `interactiveTokens` already ensures knowability and ownership/role
							return { token: tokenData, index: originalIndex };
						}
					}
					return null; // No interactive token found at position
				}

				function handleInteractionStart(clientX, clientY) {
					if (isLoading || isContextMenuOpen) return; // Prevent interaction while loading or menu is open

					const rect = canvas.getBoundingClientRect();
					const canvasX = (clientX - rect.left - panX) / scale;
					const canvasY = (clientY - rect.top - panY) / scale;

					// console.log(`Interaction start at canvasX: ${canvasX}, canvasY: ${canvasY}`); // Verbose log

					if (currentInteractionMode === 'interact') {
						const tokenInfo = getTokenAtPosition(canvasX, canvasY);
						// The filter in getTokenAtPosition already handles DM/ownership checks and knowability
						if (tokenInfo) {
							draggedToken = tokenInfo.token;
							draggedTokenIndex = tokenInfo.index;
							// Calculate offset relative to token's top-left corner of its bounding box
							offsetX = canvasX - draggedToken.x * gridSize;
							offsetY = canvasY - draggedToken.y * gridSize;
							// console.log(`Dragging token: ${draggedToken.name}, offsetX: ${offsetX}, offsetY: ${offsetY}`); // Verbose log
							drawGrid();
						} else {
							// Start panning if no interactive token is clicked at this mode
							isPanning = true;
							startX = clientX;
							startY = clientY;
							// console.log('Starting panning'); // Verbose log
						}
					} else if (currentRole === 'dm' && (currentInteractionMode === 'draw' || currentInteractionMode === 'erase')) {
						// Only DM can draw/erase walls
						const gridX = Math.floor(canvasX / gridSize);
						const gridY = Math.floor(canvasY / gridSize);
						if (gridX >= 0 && gridX < currentGridWidthCells && gridY >= 0 && gridY < currentGridHeightCells) {
							// Ensure wall array is initialized for the row
							if (!walls[gridY]) walls[gridY] = Array(currentGridWidthCells).fill(0);
							// Only make a change if the state is different
							const newState = currentInteractionMode === 'draw' ? 1 : 0;
							if (walls[gridY][gridX] !== newState) {
                                pendingWallChanges[`${gridY}_${gridX}`] = newState;
							    walls[gridY][gridX] = newState;
                                maskDirty = true; // Wall changed, need mask update
							    drawGrid(); // Redraw immediately for drawing feedback
                            }
                             isDrawing = true; // Set drawing flag
                             startX = gridX; // Store start cell for potential line drawing (though current impl is pixel by pixel)
                             startY = gridY;
						}
					}
				}

								// --- Context Menu Logic ---
								// --- Context Menu Logic ---
				function showContextMenu(clientX, clientY, tokenIndex) {
					// Remove any existing context menus
					document.querySelectorAll('.token-context-menu').forEach(m => m.remove());
					// isContextMenuOpen is set to true later, after the menu is added

					const menu = document.createElement('div');
					menu.classList.add('token-context-menu');
					// Position the menu - ensure it doesn't go offscreen (basic check)
					// Initial position before size check
					let menuX = clientX;
					let menuY = clientY;

					// Add base styles before appending to measure
					if (document.body.classList.contains('dark-mode')) {
						menu.style.backgroundColor = '#222';
						menu.style.border = '1px solid white';
						menu.style.color = 'white';
					} else {
						menu.style.backgroundColor = 'white';
						menu.style.border = '1px solid black';
						menu.style.color = 'black';
					}
                    menu.style.padding = '8px';
					menu.style.zIndex = '1000'; // High z-index to be on top
					menu.style.borderRadius = '4px';
                    menu.style.boxShadow = '2px 2px 8px rgba(0,0,0,0.3)'; // Add shadow
                    menu.style.display = 'flex'; // Use flexbox for internal layout
                    menu.style.flexDirection = 'column';
                    menu.style.gap = '6px'; // Space between elements


					const token = tokensData[tokenIndex];
                    if (!token) {
                         isContextMenuOpen = false; // Reset flag if token not found
                         return;
                    }


					// Build menu content based on role and token ownership
					// Start with the token name
					let menuHTML = `<div style="font-weight: bold; margin-bottom: 2px; text-align: center;">${token.name}</div>`;

					// --- Add role-specific content inputs/displays ---
					if (currentRole === 'dm') {
						// Add all DM controls (remove button, editable inputs for rotate, sight, light, hp, init, ac)
						menuHTML += `
							<button class="remove-token" style="width: 100%; background: #ffdddd; border: 1px solid red; padding: 6px; cursor: pointer;">Remove Token</button>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Rotate:</label>
								<input type="number" class="rotate-input" value="${token.rotation || 0}" min="0" max="360" step="1" style="flex-grow: 1; padding: 4px;">
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Sight:</label>
								<input type="number" class="sight-input" value="${token.sightRadius || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Is Light Source:</label>
                                <input type="checkbox" id="context-isLightSource" class="light-source-checkbox" ${token.isLightSource ? 'checked' : ''} style="flex-grow: 1;">
                            </div>
                            <div class="light-range-inputs" style="display: ${token.isLightSource ? 'flex' : 'none'}; flex-direction: column; gap: 6px; padding-left: 10px; border-left: 1px solid #ccc;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                     <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Bright:</label>
                                     <input type="number" id="context-bright-range" class="bright-range-input" value="${token.brightRange || 0}" min="0" style="flex-grow: 1; padding: 4px;">
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                     <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Dim:</label>
                                     <input type="number" id="context-dim-range" class="dim-range-input" value="${token.dimRange || 0}" min="0" style="flex-grow: 1; padding: 4px;">
                                </div>
                            </div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Max HP:</label>
								<input type="number" class="max-hp-input" value="${token.maxHP || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Cur HP:</label>
								<input type="number" class="hp-input" value="${token.hp || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
								<input type="number" class="init-input" value="${token.initiative || 0}" style="flex-grow: 1; padding: 4px;">
							</div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">AC:</label>
								<input type="number" class="ac-input" value="${token.ac || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
						`;

					} else if (token.owner === username || (token.isMinion && token.parentOwner === username)) {
						// Player owns token - Add player-editable fields (Rotate) and viewable (Sight, Light, HP, Init, AC)
						menuHTML += `
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Rotate:</label>
								<input type="number" class="rotate-input" value="${token.rotation || 0}" min="0" max="360" step="1" style="flex-grow: 1; padding: 4px;">
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Sight:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.sightRadius || 0}</div>
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Light:</label>
                                 <div style="flex-grow: 1; font-size: 0.9em;">${token.isLightSource ? `${token.brightRange || 0}/${token.dimRange || 0}` : 'No'}</div>
							</div>
                            <!-- Add read-only HP, Init, and AC displays for player-owned tokens -->
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">HP:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.maxHP > 0 && token.hp !== undefined ? `${token.hp}/${token.maxHP}` : (token.hp !== undefined ? token.hp : '--/--')}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.initiative !== undefined ? token.initiative : '--'}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">AC:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.ac !== undefined ? token.ac : '--'}</div>
                             </div>
                             <!-- Optional: Add player-editable HP/Init here if desired. Uncomment and update Save logic below. -->
                             <!--
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Cur HP:</label>
                                <input type="number" class="hp-input" value="${token.hp || 0}" min="0" style="flex-grow: 1; padding: 4px;">
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
                                <input type="number" class="init-input" value="${token.initiative || 0}" style="flex-grow: 1; padding: 4px;">
                            </div>
                            -->
						`;

					} else {
                        // Player does not own token - Add name and read-only info (Light, maybe HP/Init/AC)
                        // For non-owned tokens, let's add read-only HP, Init, and AC too, as they are combat relevant
                         menuHTML += `
                            <div style="font-size: 0.9em; padding: 6px; text-align: center;">(You don't own this token)</div>
                             <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Light:</label>
                                 <div style="flex-grow: 1; font-size: 0.9em;">${token.isLightSource ? `${token.brightRange || 0}/${token.dimRange || 0}` : 'No'}</div>
							</div>
                            <!-- Add read-only displays for HP/Init/AC for non-owned tokens -->
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">HP:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.maxHP > 0 && token.hp !== undefined ? `${token.hp}/${token.maxHP}` : (token.hp !== undefined ? token.hp : '--/--')}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.initiative !== undefined ? token.initiative : '--'}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">AC:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.ac !== undefined ? token.ac : '--'}</div>
                             </div>
                        `;
                    }

                    // --- Now add the buttons using correct JavaScript conditionals ---
                    // This block correctly appends the appropriate buttons AFTER the content HTML
                    if (currentRole === 'dm' || token.owner === username || (token.isMinion && token.parentOwner === username)) {
                         // If user is DM OR owns the token (or its minion), add Save and Cancel buttons
                         menuHTML += `
                            <div style="display: flex; gap: 6px; margin-top: 4px;">
                                <button class="save-button" style="flex-grow: 1; background: #ddffdd; border: 1px solid green; padding: 6px; cursor: pointer;">Save</button>
                                <button class="cancel-button" style="flex-grow: 1; background: #dddddd; border: 1px solid gray; padding: 6px; cursor: pointer;">Cancel</button>
                            </div>
                         `;
                    } else {
                         // Otherwise (user is a player and *doesn't* own the token), add only the Close button
                         menuHTML += `<button class="cancel-button" style="width: 100%; background: #dddddd; border: 1px solid gray; padding: 6px; cursor: pointer; margin-top: 4px;">Close</button>`;
                    }


					menu.innerHTML = menuHTML; // Assign the final built HTML string to the menu element
					document.body.appendChild(menu); // Append the menu to the document


					// --- Attach Event Listeners (MUST query elements *after* innerHTML is set) ---

					// Positioning logic (Your original positioning logic seems correct)
					const menuWidthActual = menu.offsetWidth;
					const menuHeightActual = menu.offsetHeight;
                    menuX = clientX;
					menuY = clientY;
                    if (menuX + menuWidthActual > window.innerWidth - 10) { menuX = window.innerWidth - menuWidthActual - 10; }
                    if (menuY + menuHeightActual > window.innerHeight - 10) { menuY = window.innerHeight - menuHeightActual - 10; }
                    menuX = Math.max(10, menuX); // Ensure min 10px from left/top
                    menuY = Math.max(10, menuY);
					menu.style.left = `${menuX}px`;
					menu.style.top = `${menuY}px`;


                    // Add listener for Light Source checkbox to show/hide range inputs (DM only)
                    // Query using the ID added to the input in the DM menuHTML
					const lightSourceCheckbox = menu.querySelector('#context-isLightSource'); // Use ID
					// Also query the bright/dim inputs here for the change listener
					const brightRangeInputForListener = menu.querySelector('#context-bright-range');
					const dimRangeInputForListener = menu.querySelector('#context-dim-range');

					// The lightRangeInputsDiv itself is queried by class as it's the container div
					const lightRangeInputsDiv = menu.querySelector('.light-range-inputs');

					// This check implicitly only runs for DM menus because only DM menus have the checkbox/div
					if (lightSourceCheckbox && lightRangeInputsDiv && brightRangeInputForListener && dimRangeInputForListener) {
						lightSourceCheckbox.addEventListener('change', () => {
							const isChecked = lightSourceCheckbox.checked;
							lightRangeInputsDiv.style.display = isChecked ? 'flex' : 'none';
							// Optional: Clear values when unchecked
							if (!isChecked) {
								brightRangeInputForListener.value = '0';
								dimRangeInputForListener.value = '0';
							}
						});
						// No need to set initial state here, it's set in the menuHTML string based on token data
					}


                    // Listener for the Remove button (DM only)
					const removeButton = menu.querySelector('.remove-token');
					if (removeButton) { // This implicitly checks for DM role
						removeButton.addEventListener('click', (e) => {
                            e.stopPropagation();
							socket.emit('removeToken', token.id);
							menu.remove();
							isContextMenuOpen = false;
						});
					}

                    // Listener for the Save button (DM or Player Owner)
					const saveButton = menu.querySelector('.save-button');
					if (saveButton) { // This implicitly checks for DM or Player Owner existence because those are the only roles with this button
						saveButton.addEventListener('click', (e) => {
							e.stopPropagation();

							const rotateInput = menu.querySelector('.rotate-input');
							let rotation = rotateInput ? parseInt(rotateInput.value, 10) % 360 : token.rotation;
							if (isNaN(rotation)) rotation = token.rotation || 0;

							// Start building the update object - always include tokenId and rotation
							let statsToUpdate = { tokenId: token.id, rotation: rotation };

                            // Query all possible inputs that could exist in the menu, regardless of role.
                            // Their values will only be used if the role allows it and the input element exists.
                            const maxHPInput = menu.querySelector('.max-hp-input');       // DM only
                            const hpInput = menu.querySelector('.hp-input');             // DM (or Player if uncommented)
                            const initInput = menu.querySelector('.init-input');           // DM (or Player if uncommented)
                            const acInput = menu.querySelector('.ac-input');             // DM only
                            const sightInput = menu.querySelector('.sight-input');         // DM only
                            const lightSourceCheckboxForSave = menu.querySelector('#context-isLightSource'); // DM only (Use the ID)
                            const brightRangeInputForSave = menu.querySelector('#context-bright-range');     // DM only (Use the ID)
                            const dimRangeInputForSave = menu.querySelector('#context-dim-range');         // DM only (Use the ID)


							// Add editable field values to statsToUpdate if they exist in the menu HTML for this role
							// These checks implicitly handle which fields were available to the user
							if (maxHPInput) statsToUpdate.maxHP = parseInt(maxHPInput.value, 10) || token.maxHP; // Use existing token stat as fallback if input is missing or parsing fails
							if (hpInput) statsToUpdate.hp = parseInt(hpInput.value, 10) || token.hp;
							if (initInput) statsToUpdate.initiative = parseInt(initInput.value, 10) || token.initiative;
							if (acInput) statsToUpdate.ac = parseInt(acInput.value, 10) || token.ac;
                            if (sightInput) statsToUpdate.sightRadius = parseInt(sightInput.value, 10) || token.sightRadius;
                            // Use the correctly queried lightSourceCheckbox variable
                            if (lightSourceCheckboxForSave) statsToUpdate.isLightSource = lightSourceCheckboxForSave.checked;
                            if (brightRangeInputForSave) statsToUpdate.brightRange = parseInt(brightRangeInputForSave.value, 10) || token.brightRange;
                            if (dimRangeInputForSave) statsToUpdate.dimRange = parseInt(dimRangeInputForSave.value, 10) || token.dimRange;


                            // Ensure dim is always >= bright before sending (Server does this too, but belt-and-suspenders)
                            // Use default 0 if brightRange/dimRange are not defined yet
                            const finalBright = statsToUpdate.brightRange !== undefined ? statsToUpdate.brightRange : (token.brightRange || 0);
                            const finalDim = statsToUpdate.dimRange !== undefined ? statsToUpdate.dimRange : (token.dimRange || 0);
                            statsToUpdate.dimRange = Math.max(finalBright, finalDim);
                            statsToUpdate.brightRange = finalBright; // Ensure brightRange is also explicitly sent


                            // Emit the update - Server will handle permissions based on role and ownership
                            // The statsToUpdate object now contains all fields that *could* have been edited.
                            // Server side should only apply fields permitted for the user's role/ownership.
							socket.emit('updateTokenStats', statsToUpdate);

							menu.remove();
							isContextMenuOpen = false;
						});
					}

                    // Listener for the Cancel/Close button (All roles)
					const cancelButton = menu.querySelector('.cancel-button');
					if (cancelButton) { // This button always exists
						cancelButton.addEventListener('click', (e) => {
							e.stopPropagation();
							menu.remove();
							isContextMenuOpen = false;
						});
					}

					// Prevent clicks/touches inside the menu from closing it immediately via document listeners
					menu.addEventListener('click', (e) => e.stopPropagation());
                    menu.addEventListener('touchstart', (e) => e.stopPropagation());


					// Add listeners to close menu when clicking/touching outside
					// These need to be added to the document, but *after* the menu exists
					function closeMenu(event) {
						// Check if the event target is outside the menu.
						if (isContextMenuOpen && menu && !menu.contains(event.target)) {
							menu.remove();
							isContextMenuOpen = false;
							// Remove these specific listeners after closing
							document.removeEventListener('click', closeMenu);
							document.removeEventListener('touchstart', closeMenu);
                            document.removeEventListener('contextmenu', closeMenu);
						}
					}

                    // Use requestAnimationFrame to delay adding the listeners slightly
                    // This prevents the current click/touch that opened the menu from immediately closing it
					requestAnimationFrame(() => {
						document.addEventListener('click', closeMenu);
						document.addEventListener('touchstart', closeMenu);
                        document.addEventListener('contextmenu', closeMenu); // Also close on right-click outside
					});

                    // Set the flag to true after the menu is fully shown and listeners are attached
                    // isContextMenuOpen is set to true at the very start of the function now. No need to set it here again.
				} // End showContextMenu

				function handleLongPress(clientX, clientY) {
					if (isLoading || currentInteractionMode !== 'interact' || isContextMenuOpen) return;

					const rect = canvas.getBoundingClientRect();
					const canvasX = (clientX - rect.left - panX) / scale;
					const canvasY = (clientY - rect.top - panY) / scale;

					const tokenInfo = getTokenAtPosition(canvasX, canvasY);
					// Show context menu if a token is hit, regardless of ownership (limited options for others)
					if (tokenInfo) {
						showContextMenu(clientX, clientY, tokenInfo.index);
					}
				}

				function resetInteraction() {
					// If wall drawing was in progress, emit the changes
					if (isDrawing && Object.keys(pendingWallChanges).length > 0) {
						socket.emit('updateWalls', walls);
						pendingWallChanges = {}; // Clear pending changes after emitting
					}
					// Reset interaction states
					draggedToken = null;
					draggedTokenIndex = -1;
					isPanning = false;
					isDrawing = false; // For walls
					isLongPressing = false;
					// Clear any pending long press timer
					if (longPressTimeout) {
						clearTimeout(longPressTimeout);
						longPressTimeout = null;
					}
					// Flag mask as dirty because token movement or ending wall drawing might change visibility
                    maskDirty = true;
					drawGrid(); // Redraw to reflect final state and clear effects (like drag)
				}

				// --- Add Token Form Submission ---
				addTokenForm.addEventListener('submit', (event) => {
					event.preventDefault();
					event.stopPropagation();

					// Get form values
					const nameValue = document.getElementById('token-name').value.trim();
					const imageValue = document.getElementById('token-image').value.trim();
					const imageFile = document.getElementById('token-image-file').files[0];
					const colorValue = document.getElementById('token-color').value.trim();
					const sizeValue = parseInt(document.getElementById('token-size').value, 10);
					const rotationValue = parseInt(document.getElementById('token-rotation').value, 10) % 360;
					// DM-only fields - check if element exists before accessing value
					const maxHPInput = document.getElementById('token-max-hp');
					const hpInput = document.getElementById('token-hp');
					const initInput = document.getElementById('token-init');
					const acInput = document.getElementById('token-ac');
                    const sightRadiusInput = document.getElementById('token-sight-radius');
                    const isLightSourceCheckbox = document.getElementById('isLightSource');
                    const brightRangeInput = document.getElementById('token-bright-range');
                    const dimRangeInput = document.getElementById('token-dim-range');


					const maxHPValue = currentRole === 'dm' && maxHPInput ? (parseInt(maxHPInput.value, 10) || 0) : 0;
					const hpValue = currentRole === 'dm' && hpInput ? (parseInt(hpInput.value, 10) || 0) : 0;
					const initValue = initInput ? (parseInt(initInput.value, 10) || 0) : 0; // Init can be set by players too? Current form says DM-only class, so treat as DM-only for submission
					const acValue = acInput ? (parseInt(acInput.value, 10) || 0) : 0;     // AC can be set by players too? Current form says DM-only class, so treat as DM-only for submission
					const sightRadiusValue = currentRole === 'dm' && sightRadiusInput ? (parseInt(sightRadiusInput.value, 10) || 0) : 0; // Sight is DM-only
                    const isLightSource = currentRole === 'dm' && isLightSourceCheckbox ? isLightSourceCheckbox.checked : false; // Light is DM-only
                    const brightRangeValue = currentRole === 'dm' && isLightSource && brightRangeInput ? (parseInt(brightRangeInput.value, 10) || 0) : 0; // Bright is DM-only
                    const dimRangeValue = currentRole === 'dm' && isLightSource && dimRangeInput ? (parseInt(dimRangeInput.value, 10) || 0) : 0; // Dim is DM-only


					const isMinion = document.getElementById('isMinion').checked;

					function submitToken(imageUrl) {
						if (!imageUrl && !colorValue) {
							showNotification('Please provide either an image (URL or file) or a color for the token.', true);
							return;
						}

						const newTokenData = {
							name: nameValue || 'Unnamed Token', // Default name
							x: Math.floor(currentGridWidthCells / 2), // Default position
							y: Math.floor(currentGridHeightCells / 2),
							imageUrl: imageUrl || null,
							imageFilename: imageFile ? imageFile.name : null,
							backgroundColor: !imageUrl ? (colorValue || 'grey') : null,
							size: sizeValue || 1, // Default size
							rotation: rotationValue || 0, // Default rotation

							// Include DM-only stats (will be validated/ignored by server if role is not DM)
							maxHP: maxHPValue,
							hp: hpValue,
							initiative: initValue, // Send initiative/AC even if DM-only class, server will handle role check
							ac: acValue,
                            sightRadius: sightRadiusValue,
                            isLightSource: isLightSource,
                            brightRange: brightRangeValue,
                            dimRange: dimRangeValue,

							isMinion: isMinion,
							owner: username // Set owner based on logged-in user
							// parentOwner set on server if isMinion is true
						};

						console.log(`Attempting to add token: ${newTokenData.name}`);

						try {
							socket.emit('addToken', newTokenData);
						} catch (err) {
							console.error('Error emitting addToken:', err);
							showNotification('Failed to add token. Please try again.', true);
						}

						// Clear the form after submission
						document.getElementById('token-name').value = '';
						document.getElementById('token-image').value = '';
						document.getElementById('token-image-file').value = '';
						document.getElementById('token-color').value = '';
						document.getElementById('token-size').value = '1';
						document.getElementById('token-rotation').value = '0';
                        // Clear DM-only fields only if they exist (DM view)
						if (maxHPInput) maxHPInput.value = '0';
						if (hpInput) hpInput.value = '0';
						if (initInput) initInput.value = '0';
						if (acInput) acInput.value = '0';
                        if (sightRadiusInput) sightRadiusInput.value = '30'; // Reset sight radius default
                        if (isLightSourceCheckbox) isLightSourceCheckbox.checked = false; // Reset light source toggle
                        // Hide light range inputs and reset their values if they exist
                        const lightRangeInputsDiv = document.querySelector('#add-token-form .light-range-inputs');
                         if (lightRangeInputsDiv) lightRangeInputsDiv.style.display = 'none';
                         if (brightRangeInput) document.getElementById('token-bright-range').value = '0';
                         if (dimRangeInput) document.getElementById('token-dim-range').value = '0';


						document.getElementById('isMinion').checked = false;
					}

					if (imageFile) {
						imageToDataUrl(imageFile, (dataUrl) => {
							submitToken(dataUrl);
						});
					} else {
						submitToken(imageValue);
					}
				});

                // Add listener for Light Source checkbox in the DM Add Token form
                const addTokenLightSourceCheckbox = document.getElementById('isLightSource');
                const addTokenLightRangeInputsDiv = document.querySelector('#add-token-form .light-range-inputs');
                if (addTokenLightSourceCheckbox && addTokenLightRangeInputsDiv) {
                    addTokenLightSourceCheckbox.addEventListener('change', () => {
                        addTokenLightRangeInputsDiv.style.display = addTokenLightSourceCheckbox.checked ? 'flex' : 'none';
                    });
                     // Set initial display based on default checkbox state
                     addTokenLightRangeInputsDiv.style.display = addTokenLightSourceCheckbox.checked ? 'flex' : 'none';
                }


				// --- Player Token Form Submission ---
				playerTokenForm.addEventListener('submit', (event) => {
					event.preventDefault();
					event.stopPropagation();

					// Get form values
					const nameValue = document.getElementById('player-token-name').value.trim();
					const imageValue = document.getElementById('player-token-image').value.trim();
					const imageFile = document.getElementById('player-token-image-file').files[0];
					const colorValue = document.getElementById('player-token-color').value.trim();
					const sizeValue = parseInt(document.getElementById('player-token-size').value, 10);
					const rotationValue = parseInt(document.getElementById('player-token-rotation').value, 10) % 360;
					const isMinion = document.getElementById('playerIsMinion').checked;

					// Player tokens have default/no values for DM-only stats/light when added
					const playerDefaultSightRadius = 30; // Define default sight radius for player tokens

					function submitPlayerToken(imageUrl) {
						if (!imageUrl && !colorValue) {
							showNotification('Please provide either an image (URL or file) or a color for the token.', true);
							return;
						}

						const newTokenData = {
							// ID is generated on the server
							name: nameValue || `${username || 'Player'}'s Token`, // Default name
							x: Math.floor(currentGridWidthCells / 2), // Default position
							y: Math.floor(currentGridHeightCells / 2),
							imageUrl: imageUrl || null,
							imageFilename: imageFile ? imageFile.name : null,
							backgroundColor: !imageUrl ? (colorValue || 'grey') : null,
							size: sizeValue || 1, // Default size
							rotation: rotationValue || 0, // Default rotation

							// DM-only fields default to 0 or false for player-added tokens
							maxHP: 0,
							hp: 0,
							initiative: 0,
							ac: 0,
                            sightRadius: playerDefaultSightRadius, // Assign default sight radius
                            isLightSource: false, // Players cannot add light sources
                            brightRange: 0,
                            dimRange: 0,

							isMinion: isMinion, // Player can mark their own as minions?
							owner: username // Set owner based on logged-in user
							// parentOwner set on server if isMinion is true
						};

						console.log(`Attempting to add player token: ${newTokenData.name}`);

						try {
							socket.emit('addToken', newTokenData);
						} catch (err) {
							console.error('Error emitting addToken:', err);
							showNotification('Failed to add token. Please try again.', true);
						}

						// Clear the form after submission
						document.getElementById('player-token-name').value = '';
						document.getElementById('player-token-image').value = '';
						document.getElementById('player-token-image-file').value = '';
						document.getElementById('player-token-color').value = '';
						document.getElementById('player-token-size').value = '1';
						document.getElementById('player-token-rotation').value = '0';
						document.getElementById('playerIsMinion').checked = false;
					}

					if (imageFile) {
						imageToDataUrl(imageFile, (dataUrl) => {
							submitPlayerToken(dataUrl);
						});
					} else {
						submitPlayerToken(imageValue);
					}
				});


				darkModeToggle.addEventListener('click', () => {
					const isDarkMode = !document.body.classList.contains('dark-mode');
					document.body.classList.toggle('dark-mode', isDarkMode);
					darkModeToggle.textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
					localStorage.setItem('darkMode', isDarkMode);
					updateDarkModeStyles(isDarkMode);
					drawGrid();
				});

				showControlsButton.addEventListener('click', () => {
					controlsWrapper.style.display = 'block';
					showControlsButton.style.display = 'none';
				});

				closeControlsButton.addEventListener('click', () => {
					controlsWrapper.style.display = 'none';
					showControlsButton.style.display = 'block';
				});

				gridSizeSelect.addEventListener('change', () => {
					if (currentRole !== 'dm') {
                         showNotification("Only the DM can change the scene size.", false);
                         // Revert the select value visually if player tried to change it
                         const currentSizeKey = Object.keys(gridSizeOptions).find(
                            key => gridSizeOptions[key].width === currentGridWidthCells &&
                                   gridSizeOptions[key].height === currentGridHeightCells
                         ) || 'small';
                         gridSizeSelect.value = currentSizeKey;
                         return; // Prevent players from changing size
                    }
					const sizeKey = gridSizeSelect.value;
					const newGridSize = gridSizeOptions[sizeKey];

                    if (!newGridSize) {
                         console.error("Unknown grid size selected:", sizeKey);
                         showNotification("Error: Invalid grid size selected.", true);
                         // Revert the select value visually
                          const currentSizeKey = Object.keys(gridSizeOptions).find(
                            key => gridSizeOptions[key].width === currentGridWidthCells &&
                                   gridSizeOptions[key].height === currentGridHeightCells
                         ) || 'small';
                         gridSizeSelect.value = currentSizeKey;
                         return;
                    }

                    // Send grid size update to server. Server will broadcast fullStateUpdate including normalized walls and token positions.
					socket.emit('updateGridSize', { width: newGridSize.width, height: newGridSize.height });

                    // Client side update will happen when 'fullStateUpdate' is received
                    // Don't change local state immediately here, rely on server broadcast
                    showNotification(`Grid size updated to ${newGridSize.width}x${newGridSize.height}.`);
				});


				// --- Interaction Mode Buttons ---
				function setInteractionMode(mode) {
					currentInteractionMode = mode;
					// Reset button styles
					interactButton.style.backgroundColor = '';
					drawWallButton.style.backgroundColor = '';
					eraseWallButton.style.backgroundColor = '';

					// Set active button style
					if (mode === 'interact') {
						interactButton.style.backgroundColor = '#5bc0de';
					} else if (mode === 'draw') {
						drawWallButton.style.backgroundColor = '#5bc0de';
					} else if (mode === 'erase') {
						eraseWallButton.style.backgroundColor = '#5bc0de';
					}
                    // No need to drawGrid immediately, will happen on next mouse/touch event
				}

				interactButton.addEventListener('click', () => setInteractionMode('interact'));
				drawWallButton.addEventListener('click', () => {
                    if (currentRole !== 'dm') {
                         showNotification("Only the DM can draw walls.", false);
                         return;
                    }
                    setInteractionMode('draw');
                });
				eraseWallButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can erase walls.", false);
                         return;
                    }
                    setInteractionMode('erase');
                });

                // Set initial mode style
                setInteractionMode(currentInteractionMode);


				toggleGridButton.addEventListener('click', () => {
					if (currentRole === 'dm') {
						socket.emit('updateGridVisibility', !isGridVisible);
					} else {
                         showNotification("Only the DM can toggle the grid lines.", false);
                    }
				});

				resetViewButton.addEventListener('click', () => {
					scale = 1;
					// Center the grid in the canvas
					panX = (canvas.width - currentGridWidthCells * gridSize * scale) / 2;
					panY = (canvas.height - currentGridHeightCells * gridSize * scale) / 2;
					drawGrid();
				});

				backgroundForm.addEventListener('submit', (event) => event.preventDefault()); // Prevent default form submit

				loadBackgroundButton.addEventListener('click', () => {
					if (currentRole !== 'dm') {
                         showNotification("Only the DM can change the background.", false);
                         return;
                    }
					const url = backgroundImageUrlInput.value.trim();
					if (url) {
						socket.emit('updateBackground', url);
                        showNotification('Sending background URL to server...');
					} else {
                         showNotification("Please enter a background image URL.", false);
                    }
				});

				clearBackgroundButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can clear the background.", false);
                         return;
                    }
					socket.emit('updateBackground', '');
                    showNotification('Clearing background...');
				});

				backgroundImageFileInput.addEventListener('change', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can upload a background.", false);
                         return;
                    }
					const file = backgroundImageFileInput.files[0];
					if (file) {
						imageToDataUrl(file, (dataUrl) => {
							if (dataUrl) {
								socket.emit('updateBackground', dataUrl);
                                showNotification('Uploading background image...');
							} else {
                                showNotification("Failed to read background image file.", true);
                            }
						});
                        backgroundImageFileInput.value = ''; // Clear file input
					}
				});

				saveStateButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can save the state.", false);
                         return;
                    }
					socket.emit('saveState');
					// Notification handled by server 'saveSuccess' event
				});

				downloadStateButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can download the state.", false);
                         return;
                    }
					const state = {
						tokens: tokensData.map(token => ({ // Strip imageObj for download
                            id: token.id,
                            name: token.name,
                            x: token.x,
                            y: token.y,
                            imageUrl: token.imageUrl,
                            imageFilename: token.imageFilename,
                            backgroundColor: token.backgroundColor,
                            size: token.size,
                            rotation: token.rotation,
                            maxHP: token.maxHP,
                            hp: token.hp,
                            initiative: token.initiative,
                            ac: token.ac,
                            sightRadius: token.sightRadius, // Include sight radius
                            isLightSource: token.isLightSource, // Include light source properties
                            brightRange: token.brightRange,
                            dimRange: token.dimRange,
                            isMinion: token.isMinion,
                            owner: token.owner,
                            parentOwner: token.parentOwner
                        })),
						walls: normalizeWalls(walls, currentGridWidthCells, currentGridHeightCells),
						backgroundImageUrl,
						gridSize: { width: currentGridWidthCells, height: currentGridHeightCells },
                        // Optionally save current view state (pan/scale) - Note: This isn't currently loaded by server/client
                        // viewState: { scale, panX, panY } // Let's remove this from the download state for now to keep it simple
					};
					const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = 'thorgrid-state.json'; // Use app name
					a.click();
					URL.revokeObjectURL(url);
					showNotification('State downloaded.');
				});

				importStateButton.addEventListener('click', () => {
                    if (currentRole !== 'dm') {
                         showNotification("Only the DM can import the state.", false);
                         return;
                    }
					importStateFile.click();
				});

				importStateFile.addEventListener('change', () => {
					const file = importStateFile.files[0];
					if (file) {
						const reader = new FileReader();
						reader.onload = (e) => {
							try {
								const state = JSON.parse(e.target.result);
                                // Basic validation before emitting to server
                                if (state && Array.isArray(state.tokens) && Array.isArray(state.walls) && state.gridSize) {
                                    socket.emit('importState', state); // Server handles processing and broadcasting fullStateUpdate
                                    showNotification('Importing state...');
                                    // Notification handled by server 'saveSuccess' event after successful import
                                } else {
                                     showNotification('Invalid state file format.', true);
                                }
							} catch (err) {
								console.error('Failed to parse imported state:', err);
								showNotification('Failed to import state. Invalid JSON.', true);
							}
						};
						reader.onerror = () => {
							console.error('Failed to read file:', file.name);
							showNotification('Failed to read file.', true);
						};
						reader.readAsText(file);
						importStateFile.value = ''; // Clear file input
					}
				});

				canvas.addEventListener('mousedown', (event) => {
                    // Only process if not loading and not in context menu
                    if (isLoading || isContextMenuOpen) return;

					if (event.button === 0) { // Left click
						handleInteractionStart(event.clientX, event.clientY);
					}
				});

				canvas.addEventListener('contextmenu', (event) => {
					event.preventDefault();
					if (isLoading || currentInteractionMode !== 'interact' || isContextMenuOpen) return;

					const rect = canvas.getBoundingClientRect();
					const canvasX = (event.clientX - rect.left - panX) / scale;
					const canvasY = (event.clientY - rect.top - panY) / scale;

					const tokenInfo = getTokenAtPosition(canvasX, canvasY);
					// Show context menu if a token is hit, regardless of ownership (limited options for others)
					if (tokenInfo) {
						showContextMenu(event.clientX, event.clientY, tokenInfo.index);
					}
				});

				canvas.addEventListener('mousemove', (event) => {
					const rect = canvas.getBoundingClientRect();
					const canvasX = (event.clientX - rect.left - panX) / scale;
					const canvasY = (event.clientY - rect.top - panY) / scale;

					if (draggedToken) {
						const tokenSize = draggedToken.size || 1;
						// Calculate target cell based on mouse position relative to the token's top-left corner
						const newX = Math.floor((canvasX - offsetX) / gridSize);
						const newY = Math.floor((canvasY - offsetY) / gridSize);
						const maxX = currentGridWidthCells - tokenSize;
						const maxY = currentGridHeightCells - tokenSize;

						// Clamp to grid bounds
						const clampedX = Math.max(0, Math.min(newX, maxX));
						const clampedY = Math.max(0, Math.min(newY, maxY));

						// Only update and emit if the cell position actually changed
						if (draggedToken.x !== clampedX || draggedToken.y !== clampedY) {
							draggedToken.x = clampedX;
							draggedToken.y = clampedY;
							// console.log(`Moving token ${draggedToken.name} to x: ${draggedToken.x}, y: ${draggedToken.y}`); // COMMENTED OUT
							socket.emit('moveToken', {
								tokenId: draggedToken.id,
								x: draggedToken.x,
								y: draggedToken.y,
								rotation: draggedToken.rotation
                                // Note: stats like HP, Init, AC, Sight, Light are updated via context menu, not move
							});
                            maskDirty = true; // Token moved, need to recalculate mask
							drawGrid(); // Redraw immediately for smooth drag feedback
						}
					} else if (isPanning) {
						panX += event.clientX - startX;
						panY += event.clientY - startY;
						startX = event.clientX;
						startY = event.clientY;
						drawGrid();
					} else if (isDrawing && currentRole === 'dm' && (currentInteractionMode === 'draw' || currentInteractionMode === 'erase')) {
						const gridX = Math.floor(canvasX / gridSize);
						const gridY = Math.floor(canvasY / gridSize);
						if (gridX >= 0 && gridX < currentGridWidthCells && gridY >= 0 && gridY < currentGridHeightCells) {
							// Ensure wall array is initialized for the row
							if (!walls[gridY]) walls[gridY] = Array(currentGridWidthCells).fill(0);
							// Only make a change if the state is different
							const newState = currentInteractionMode === 'draw' ? 1 : 0;
							if (walls[gridY][gridX] !== newState) {
                                pendingWallChanges[`${gridY}_${gridX}`] = newState;
							    walls[gridY][gridX] = newState;
                                maskDirty = true; // Wall changed, need mask update
							    drawGrid(); // Redraw immediately for drawing feedback
                            }
						}
					} else {
                        // Handle hover for token name visibility
						const tokenInfo = getTokenAtPosition(canvasX, canvasY);
						const newHoveredIndex = tokenInfo ? tokenInfo.index : -1;
						if (newHoveredIndex !== hoveredTokenIndex) {
							hoveredTokenIndex = newHoveredIndex;
							drawGrid(); // Redraw to show/hide/update hovered name
						}
					}
				});

				canvas.addEventListener('mouseup', () => {
					resetInteraction(); // Emits wall changes if drawing
				});

				canvas.addEventListener('mouseleave', () => {
                    // Only reset if not currently dragging or panning (e.g., cursor leaves during interaction)
                    // If dragging/panning, the touchend/mouseup will handle the final reset.
                    // This specifically handles the case where the mouse leaves the canvas area.
                    if (!draggedToken && !isPanning && !isDrawing && !isLongPressing && !isContextMenuOpen) {
					    resetInteraction(); // Ensures drawing/panning stops cleanly
                    }
					hoveredTokenIndex = -1; // Clear hover state
                    // Only redraw if the hovered state actually changed
                    if (hoveredTokenIndex !== -1) drawGrid(); // Redraw to remove hover effect/name
				});

				canvas.addEventListener('touchstart', (event) => {
					event.preventDefault();
                    if (isLoading || isContextMenuOpen) { // Prevent interaction while loading or menu is open
                         if (longPressTimeout) clearTimeout(longPressTimeout); // Clear any accidental timeout
                         isLongPressing = false;
                         return;
                    }

					if (event.touches.length === 1) {
						const touch = event.touches[0];
						handleInteractionStart(touch.clientX, touch.clientY);
						longPressStartX = touch.clientX;
						longPressStartY = touch.clientY;
                        // Start timer for long press context menu
                        // Only start if no token was immediately selected for drag (check `draggedToken`)
                        // This avoids showing the context menu immediately on drag start.
                        if (!draggedToken && currentInteractionMode === 'interact') {
                            longPressTimeout = setTimeout(() => {
                                isLongPressing = true;
                                // Check if finger hasn't moved too much - This check is better in touchmove/touchend
                                // Let the timeout just set the flag and call the menu handler
                                handleLongPress(longPressStartX, longPressStartY);

                            }, 500); // 500ms for long press
                        } else {
                             // If a token was selected for drag immediately, it's not a long press intent
                             if (longPressTimeout) clearTimeout(longPressTimeout);
                             isLongPressing = false;
                        }
					} else if (event.touches.length === 2) {
						// Handle pinch-to-zoom
						resetInteraction(); // Stop any dragging/drawing first
                        if (longPressTimeout) clearTimeout(longPressTimeout);
                        isLongPressing = false; // Cancel long press

						const touch1 = event.touches[0];
						const touch2 = event.touches[1];
						pinchStartDistance = Math.hypot(
							touch1.clientX - touch2.clientX,
							touch1.clientY - touch2.clientY
						);
						pinchStartScale = scale;
						pinchStartCenterX = (touch1.clientX + touch2.clientX) / 2;
						pinchStartCenterY = (touch1.clientY + touch2.clientY) / 2;
					} else {
                         // More than 2 touches, ignore or reset
                         resetInteraction();
                         if (longPressTimeout) clearTimeout(longPressTimeout);
                         isLongPressing = false;
                    }
				});

				canvas.addEventListener('touchmove', (event) => {
					event.preventDefault();
                    if (isLoading || isContextMenuOpen) return;

                    // If finger moves significantly during potential long press, cancel it
                    if (longPressTimeout && event.touches.length === 1) {
                         const touch = event.touches[0];
                         const dx = touch.clientX - longPressStartX;
                         const dy = touch.changedTouches[0].clientY - longPressStartY; // Fixed: Use changedTouches for accurate delta
                         const distance = Math.sqrt(dx*dx + dy*dy);
                         if (distance > 10) { // Moved more than threshold (e.g., 10 pixels)
                             clearTimeout(longPressTimeout);
                             longPressTimeout = null;
                             isLongPressing = false;
                             // If dragging hadn't started yet but we moved, start dragging
                             if (!draggedToken && !isPanning && !isDrawing) {
                                  // Re-evaluate interaction start at the original long press position
                                  // to see if a token was under the initial touch.
                                   const rect = canvas.getBoundingClientRect();
                                   handleInteractionStart(longPressStartX, longPressStartY);
                             }
                         }
                    }


					const rect = canvas.getBoundingClientRect();
					if (event.touches.length === 1 && !isLongPressing) { // Ensure not in long press mode
						const touch = event.touches[0];
						const canvasX = (touch.clientX - rect.left - panX) / scale;
						const canvasY = (touch.clientY - rect.top - panY) / scale;

						if (draggedToken) {
							const tokenSize = draggedToken.size || 1;
                            // Calculate target cell based on touch position relative to the token's top-left corner
							const newX = Math.floor((canvasX - offsetX) / gridSize);
							const newY = Math.floor((canvasY - offsetY) / gridSize);
							const maxX = currentGridWidthCells - tokenSize;
							const maxY = currentGridHeightCells - tokenSize;

							// Clamp to grid bounds
							const clampedX = Math.max(0, Math.min(newX, maxX));
							const clampedY = Math.max(0, Math.min(newY, maxY));


							if (draggedToken.x !== clampedX || draggedToken.y !== clampedY) {
								draggedToken.x = clampedX;
								draggedToken.y = clampedY;
								// console.log(`Touch moving token ${draggedToken.name} to x: ${draggedToken.x}, y: ${draggedToken.y}`); // COMMENTED OUT
								socket.emit('moveToken', {
									tokenId: draggedToken.id,
									x: draggedToken.x,
									y: draggedToken.y,
									rotation: draggedToken.rotation
								});
                                maskDirty = true; // Token moved, need mask update
								drawGrid(); // Redraw immediately
							}
						} else if (isPanning) {
							panX += touch.clientX - startX;
							panY += touch.clientY - startY;
							startX = touch.clientX;
							startY = touch.clientY;
							drawGrid();
						} else if (isDrawing && currentRole === 'dm' && (currentInteractionMode === 'draw' || currentInteractionMode === 'erase')) {
							const gridX = Math.floor(canvasX / gridSize);
							const gridY = Math.floor(canvasY / gridSize);
							if (gridX >= 0 && gridX < currentGridWidthCells && gridY >= 0 && gridY < currentGridHeightCells) {
								// Ensure wall array is initialized for the row
								if (!walls[gridY]) walls[gridY] = Array(currentGridWidthCells).fill(0);
								// Only make a change if the state is different
                                const newState = currentInteractionMode === 'draw' ? 1 : 0;
                                if (walls[gridY][gridX] !== newState) {
								    pendingWallChanges[`${gridY}_${gridX}`] = newState;
								    walls[gridY][gridX] = newState;
                                    maskDirty = true; // Wall changed, need mask update
								    drawGrid(); // Redraw immediately
                                }
							}
						}
					} else if (event.touches.length === 2) {
                        // Pinch-to-zoom logic
						const touch1 = event.touches[0];
						const touch2 = event.touches[1];
						const newDistance = Math.hypot(
							touch1.clientX - touch2.clientX,
							touch1.clientY - touch2.clientY
						);
						const newCenterX = (touch1.clientX + touch2.clientX) / 2;
						const newCenterY = (touch1.clientY + touch2.clientY) / 2;

						const scaleFactor = newDistance / pinchStartDistance;
						const newScale = pinchStartScale * scaleFactor;
						scale = Math.max(0.2, Math.min(newScale, 5)); // Clamp scale between 0.2x and 5x

                        // Adjust pan to keep the pinch center point relatively stable on the grid
						const canvasCenterX = (pinchStartCenterX - rect.left - panX) / pinchStartScale;
						const canvasCenterY = (pinchStartCenterY - rect.top - panY) / pinchStartScale;
						panX = newCenterX - rect.left - canvasCenterX * scale;
						panY = newCenterY - rect.top - canvasCenterY * scale;

						pinchStartDistance = newDistance;
						pinchStartScale = scale;
						pinchStartCenterX = newCenterX;
						pinchStartCenterY = newCenterY;

						drawGrid();
					}
				});

				canvas.addEventListener('touchend', (event) => {
                     // If a long press timer was active, clear it and check if it was a tap vs long press
                    if (longPressTimeout) {
                         clearTimeout(longPressTimeout);
                         longPressTimeout = null;
                         // If it was a short tap (not a drag or long press), handle interaction start/click
                         // Check if touch ended *without* significant movement and was not flagged as long press
                         const dx = event.changedTouches[0].clientX - longPressStartX;
                         const dy = event.changedTouches[0].clientY - longPressStartY;
                         const distance = Math.sqrt(dx*dx + dy*dy);
                         // If interaction didn't turn into a drag/pan AND distance is small, treat as a click/tap
                         if (!draggedToken && !isPanning && !isDrawing && distance < 10 && !isLongPressing) {
                            // Simulate a click interaction at the start position
                             handleInteractionStart(longPressStartX, longPressStartY); // This will either start drag (if it wasn't picked up before) or do nothing if no token/pan/draw
                             resetInteraction(); // Then reset immediately as it was just a tap
                         }
                         isLongPressing = false; // Reset flag
                    }

                    // Reset general interaction state *only* if all touches are lifted
                    if (event.touches.length === 0) {
                        resetInteraction(); // Emits wall changes if drawing
                    }
				});

				canvas.addEventListener('touchcancel', () => {
					resetInteraction();
                     if (longPressTimeout) {
                         clearTimeout(longPressTimeout);
                         longPressTimeout = null;
                         isLongPressing = false;
                    }
				});

				canvas.addEventListener('wheel', (event) => {
					event.preventDefault();
					const rect = canvas.getBoundingClientRect();
					const mouseX = event.clientX - rect.left;
					const mouseY = event.clientY - rect.top;

					const zoomSpeed = 0.0005; // Slower zoom speed
					// Use exponential scaling for smoother zoom levels
					const zoomFactor = Math.exp(-event.deltaY * zoomSpeed);

					const canvasX = (mouseX - panX) / scale;
					const canvasY = (mouseY - panY) / scale;

					const newScale = scale * zoomFactor;
					scale = Math.max(0.2, Math.min(newScale, 5)); // Clamp scale between 0.2x and 5x

					// Adjust pan to zoom into the mouse position
					panX = mouseX - canvasX * scale;
					panY = mouseY - canvasY * scale;

					drawGrid();
				});

				window.addEventListener('resize', resizeCanvas);

				// Login handler
				document.getElementById('loginButton').addEventListener('click', () => {
					username = document.getElementById('usernameInput').value.trim();
					currentRole = document.getElementById('roleSelect').value;
					if (!username) {
						showNotification('Please enter a username.', true);
						return;
					}
					if (!socket || !socket.connected) {
						showNotification('Not connected to server. Cannot login.', true);
						return;
					}
					console.log(`Attempting login as ${username} (${currentRole})`);
					socket.emit('login', { username, role: currentRole });
				});

					socket.on('roleAssigned', ({ role, username: assignedUsername }) => {
					console.log(`Role assigned by server: ${role}, Username: ${assignedUsername}`);
					currentRole = role;
					username = assignedUsername;
					document.getElementById('loginScreen').classList.add('hidden');
					document.body.classList.add(`role-${currentRole}`);
					updateDarkModeStyles(document.body.classList.contains('dark-mode'));
					showNotification(`Logged in as ${username} (${role})`);

                    // The server address display logic is handled in determineServerUrl
                    // based on whether it's running in Electron or a browser.
                    // It doesn't need to be re-run here on role assignment.
                    // If you wanted to dynamically update it (e.g., if IP changes mid-session, unlikely)
                    // you'd need a server event for that.
                    // For now, remove the redundant display update from here.

                    // Recalculate visibility for the new role
                    maskDirty = true;
					drawGrid(); // Ensure redraw with correct mask
				});

				// Initial state load
				socket.on('init', (data) => {
					isLoading = true; // Prevent interaction while loading
					tokensData = (data.tokens || []).map(token => ({
						...token,
						// Ensure numeric positions and add default visibility/light properties if missing
						x: Number.isFinite(token.x) ? token.x : Math.floor((data.gridSize?.width || gridSizeOptions.small.width) / 2),
						y: Number.isFinite(token.y) ? token.y : Math.floor((data.gridSize?.height || gridSizeOptions.small.height) / 2),
                        sightRadius: Number.isFinite(token.sightRadius) ? token.sightRadius : 0, // Default sight radius
                        isLightSource: Boolean(token.isLightSource), // Default light source
                        brightRange: Number.isFinite(token.brightRange) ? token.brightRange : 0, // Default bright range
                        dimRange: Number.isFinite(token.dimRange) ? token.dimRange : 0,         // Default dim range (total radius)
                        // Ensure other potential missing defaults from older formats
                        maxHP: token.maxHP !== undefined ? token.maxHP : 0,
                        hp: token.hp !== undefined ? token.hp : 0,
                        initiative: token.initiative !== undefined ? token.initiative : 0,
                        ac: token.ac !== undefined ? token.ac : 0,
                        rotation: token.rotation !== undefined ? token.rotation : 0,
                        isMinion: token.isMinion !== undefined ? token.isMinion : false,
                        owner: token.owner || null,
                        parentOwner: token.parentOwner || null,
                         // Ensure token size is valid
                        size: Number.isFinite(token.size) && token.size > 0 ? token.size : 1,
                        // imageUrl/backgroundColor/imageFilename should also be handled if needed for merging
                        imageUrl: token.imageUrl || null,
                        backgroundColor: token.backgroundColor || null,
                        imageFilename: token.imageFilename || null,
					}));
					console.log('Initialized tokens:', tokensData.map(t => ({ id: t.id, name: t.name, x: t.x, y: t.y, owner: t.owner, sight: t.sightRadius, light: t.isLightSource ? `${t.brightRange}/${t.dimRange}` : 'No' })));


                    currentGridWidthCells = data.gridSize?.width || gridSizeOptions.small.width;
					currentGridHeightCells = data.gridSize?.height || gridSizeOptions.small.height;
					walls = normalizeWalls(data.walls, currentGridWidthCells, currentGridHeightCells);

					// View state from state file is currently ignored on init, relying on client's default or reset view.
                    // If you wanted to load view state:
                    // scale = data.viewState?.scale || 1;
					// panX = data.viewState?.panX || 0;
					// panY = data.viewState?.panY || 0;
                    // Centering logic handled by resizeCanvas after initial load

					isGridVisible = data.isGridVisible !== undefined ? data.isGridVisible : true;

                    // Set grid size select value based on loaded size
					const loadedSizeKey = Object.keys(gridSizeOptions).find(
						key => gridSizeOptions[key].width === currentGridWidthCells &&
							   gridSizeOptions[key].height === currentGridHeightCells
					) || 'small'; // Default to 'small' if loaded size doesn't match a preset
                    gridSizeSelect.value = loadedSizeKey;


					toggleGridButton.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
					tokensData.forEach(preloadTokenImage); // Preload images asynchronously

					loadBackgroundImage(data.backgroundImageUrl || ''); // Load background asynchronously

                    maskDirty = true; // State initialized, need to calculate and build mask
                    resizeCanvas(); // Ensure canvas size matches window and mask canvas size is set, also calls drawGrid
					// drawGrid is called recursively by requestAnimationFrame

					isLoading = false; // Loading is complete
				});

                // Listen for full state updates (used by importState on the server)
                socket.on('fullStateUpdate', (state) => {
                     isLoading = true; // Prevent interaction while updating
                     tokensData = (state.tokens || []).map(token => ({
                         ...token,
                         // Ensure numeric positions and add default visibility/light properties if missing
                         x: Number.isFinite(token.x) ? token.x : Math.floor((state.gridSize?.width || gridSizeOptions.small.width) / 2),
                         y: Number.isFinite(token.y) ? token.y : Math.floor((state.gridSize?.height || gridSizeOptions.small.height) / 2),
                         sightRadius: Number.isFinite(token.sightRadius) ? token.sightRadius : 0,
                         isLightSource: Boolean(token.isLightSource),
                         brightRange: Number.isFinite(token.brightRange) ? token.brightRange : 0,
                         dimRange: Number.isFinite(token.dimRange) ? token.dimRange : 0,
                         // Include other potential missing defaults from older formats
                         maxHP: token.maxHP !== undefined ? token.maxHP : 0,
                         hp: token.hp !== undefined ? token.hp : 0,
                         initiative: token.initiative !== undefined ? token.initiative : 0,
                         ac: token.ac !== undefined ? token.ac : 0,
                         rotation: token.rotation !== undefined ? token.rotation : 0,
                         isMinion: token.isMinion !== undefined ? token.isMinion : false,
                         owner: token.owner || null,
                         parentOwner: token.parentOwner || null,
                          // Ensure token size is valid
                         size: Number.isFinite(token.size) && token.size > 0 ? Number(token.size) : 1,
                         // imageUrl/backgroundColor/imageFilename should also be handled if needed for merging
                         imageUrl: token.imageUrl || null,
                         backgroundColor: token.backgroundColor || null,
                         imageFilename: token.imageFilename || null,

                     }));
                     currentGridWidthCells = state.gridSize?.width || gridSizeOptions.small.width;
                     currentGridHeightCells = state.gridSize?.height || gridSizeOptions.small.height;
                     walls = normalizeWalls(state.walls, currentGridWidthCells, currentGridHeightCells);
                     backgroundImageUrl = state.backgroundImageUrl || '';

                     // Load view state if present (from import)
                     scale = state.viewState?.scale || 1;
					 panX = state.viewState?.panX || 0;
					 panY = state.viewState?.panY || 0;


                     isGridVisible = state.isGridVisible !== undefined ? state.isGridVisible : true;

                     const loadedSizeKey = Object.keys(gridSizeOptions).find(
                         key => gridSizeOptions[key].width === currentGridWidthCells &&
                                gridSizeOptions[key].height === currentGridHeightCells
                     ) || 'small';
                     gridSizeSelect.value = loadedSizeKey;

                     toggleGridButton.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
                     tokensData.forEach(preloadTokenImage); // Preload images for all tokens
                     loadBackgroundImage(backgroundImageUrl);

                     maskDirty = true; // State updated, need to calculate and build mask
                     resizeCanvas(); // Ensure canvas size and mask canvas size are set, calls drawGrid
                     // drawGrid is called recursively
                     console.log("Full state update received and processed.");
                     isLoading = false; // Finished loading/processing
                });


				socket.on('updateTokens', (tokens) => {
					// Merge updates to preserve local imageObj and ensure new properties
					tokensData = tokens.map(updatedToken => {
                        const existingToken = tokensData.find(t => t.id === updatedToken.id);
                        // Use existing imageObj if available, otherwise update
                        const imageObj = existingToken ? existingToken.imageObj : null;

                         // Ensure numeric positions and default sightRadius/light properties
                         const x = Number.isFinite(updatedToken.x) ? updatedToken.x : existingToken?.x || Math.floor(currentGridWidthCells / 2);
                         const y = Number.isFinite(updatedToken.y) ? updatedToken.y : existingToken?.y || Math.floor(currentGridHeightCells / 2);
                         const sightRadius = Number.isFinite(updatedToken.sightRadius) ? updatedToken.sightRadius : (existingToken?.sightRadius || 0);
                         const isLightSource = Boolean(updatedToken.isLightSource); // Ensure boolean
                         const brightRange = Number.isFinite(updatedToken.brightRange) ? updatedToken.brightRange : (existingToken?.brightRange || 0);
                         const dimRange = Number.isFinite(updatedToken.dimRange) ? updatedToken.dimRange : (existingToken?.dimRange || 0);

                        return {
                            ...existingToken, // Keep existing properties not explicitly updated
                            ...updatedToken, // Apply updated properties
                            x, y, sightRadius, isLightSource, brightRange, dimRange, // Ensure numeric + default
                            imageObj: imageObj // Keep the loaded image object
                        };
                    });

                    // Handle removed tokens (filter out any tokens no longer in the updated list)
                    tokensData = tokensData.filter(token => tokens.some(t => t.id === token.id));

                    // Re-check hovered/dragged index in case the list changed
                    if (draggedToken && !tokensData.some(t => t.id === draggedToken.id)) {
                        draggedToken = null;
                        draggedTokenIndex = -1;
                    }
                    if (hoveredTokenIndex !== -1 && !tokensData.some(t => t.id === tokensData[hoveredTokenIndex]?.id)) {
                         hoveredTokenIndex = -1;
                    }


					// console.log('Updated tokens:', tokensData.map(t => ({ id: t.id, name: t.name, x: t.x, y: t.y, owner: t.owner, sight: t.sightRadius, light: t.isLightSource ? `${t.brightRange}/${t.dimRange}` : 'No' }))); // Less spammy token log
                    // Preload images for any newly added tokens that weren't merged
                    tokensData.forEach(token => {
                         if (!token.imageObj && token.imageUrl) {
                              preloadTokenImage(token);
                         }
                    });

                    maskDirty = true; // Tokens moved or stats/light updated, need mask update
					drawGrid(); // Redraw the grid
				});

				// Server emits updateWalls. Client receives and updates local walls.
				socket.on('updateWalls', (newWalls) => {
                    // updateGridSize also sends updateWalls, which will trigger fullStateUpdate anyway.
                    // This handler is mainly for continuous drawing/erasing.
                    // Fog of War requires mask update whenever walls change.
                    walls = normalizeWalls(newWalls, currentGridWidthCells, currentGridHeightCells);
                    maskDirty = true; // Walls changed, need mask update
                    drawGrid(); // Redraw the grid
				});

				socket.on('updateGridVisibility', (newIsGridVisible) => {
					isGridVisible = newIsGridVisible;
					if (currentRole === 'dm') {
						toggleGridButton.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
					}
					drawGrid();
				});

				socket.on('updateBackground', (url) => {
					loadBackgroundImage(url); // loadBackgroundImage already calls drawGrid
				});

				socket.on('updateGridSize', (gridSize) => {
                    // This handler is potentially redundant now that server sends fullStateUpdate on size change.
                    // The fullStateUpdate handler will update gridSize and walls.
                    // If this handler is still needed (e.g., for a direct size update that doesn't include full state),
                    // it should update local state but still trigger a mask redraw.
					currentGridWidthCells = gridSize.width;
					currentGridHeightCells = gridSize.height;
                    // Update select value
					const loadedSizeKey = Object.keys(gridSizeOptions).find(
						key => gridSizeOptions[key].width === currentGridWidthCells &&
							   gridSizeOptions[key].height === currentGridHeightCells
					) || 'small';
                    gridSizeSelect.value = loadedSizeKey;

                    // Walls will be normalized by normalizeWalls called in updateWalls (if separate event) or fullStateUpdate.
                    // No need to normalize walls here unless this event can happen *without* updateWalls/fullStateUpdate.

                    maskDirty = true; // Grid size changed, need mask update
                    resizeCanvas(); // Updates canvas size AND mask canvas size are set, calls drawGrid
				});


				socket.on('error', (message) => {
					showNotification(message, true);
                    // If username is in use, force the login screen back open
					if (message === 'Username already in use') {
						document.getElementById('loginScreen').classList.remove('hidden');
						// Reset role and username on client if login failed due to name conflict
                        currentRole = null;
                        username = null;
						document.body.className = ''; // Remove role class
                         // Re-enable login button if it was disabled during connection attempts
                         document.getElementById('loginButton').disabled = false;
                         document.getElementById('loginButton').textContent = 'Join';
					}
				});

				socket.on('saveSuccess', (message) => {
					showNotification(message);
				});

				socket.on('clients', (clientUsernames) => { // Server now sends usernames
					// console.log('Connected clients:', clientUsernames); // Keep console cleaner
				});


			} // End initializeSocket

			// Start the process by determining the server URL and then initializing the socket
			determineServerUrl();
		}); // End DOMContentLoaded listener
	</script>
	</body>
</html>