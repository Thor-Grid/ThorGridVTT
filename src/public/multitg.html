<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <!-- Updated CSP -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline';
        style-src 'self' 'unsafe-inline';
        img-src 'self' data: https:;
        media-src 'self' data:;  
        connect-src 'self' ws: wss: http: https:;
        font-src 'self';
        object-src 'none';
    ">
    <title>Thor-Grid</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        @supports (padding: env(safe-area-inset-top)) {
            body {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
        }

        .token-name {
            position: fixed;
            pointer-events: none;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 8px;
            padding-bottom: 3px; /* <--- Add this line (adjust value as needed) */
            border-radius: 4px;
            font-size: 16px;
            font-family: Arial, sans-serif;
            white-space: nowrap;
            z-index: 10;
            transform: translate(-50%, -100%);
            transition: opacity 0.2s ease;
        }

        .dark-mode .token-name {
            background-color: rgba(255, 255, 255, 0.7);
            color: black;
        }

        .token-name.hovered {
            opacity: 1 !important;
            font-weight: bold;
            background-color: rgba(0, 0, 255, 0.3);
            color: white;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }

        .dark-mode .token-name.hovered {
            background-color: rgba(0, 0, 255, 0.3);
            color: white;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }

        #grid-container, canvas {
            width: 100vw !important;
            height: 100vh !important;
            position: fixed;
            top: 0;
            left: 0;
        }

        body {
            background-color: white;
            color: black;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }

        canvas {
            border: 1px solid black;
            background-color: transparent;
            touch-action: none;
        }

        body.dark-mode {
            background-color: #121212;
            color: white;
        }

        canvas.dark-mode {
            border: 1px solid white;
        }

        #grid-container {
            position: relative;
            overflow: hidden;
        }

        #add-token-form, #player-token-form, #background-form {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
        }

        #add-token-form.dark-mode, #player-token-form.dark-mode, #background-form.dark-mode {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
        }

        #add-token-form input,
        #add-token-form select,
        #player-token-form input,
        #player-token-form select,
        #background-form input,
        #background-form select {
            margin-bottom: 6px;
            padding: 6px;
            font-size: 14px;
        }

        #controls-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 11;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            padding: 10px;
            position: fixed;
            top: 10px;
            left: 10px;
            width: 220px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #controls-container.dark-mode {
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        #core-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        details {
            margin-bottom: 8px;
        }

        summary {
            cursor: pointer;
            padding: 6px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
        }

        details[open] summary {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .dark-mode summary {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .dark-mode details[open] summary {
            background-color: rgba(255, 255, 255, 0.2);
        }

        #instructions {
            background-color: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.4;
        }

        #instructions.dark-mode {
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
        }

        #toggle-instructions-button,
        #controls-container button,
        #add-token-form button,
        #player-token-form button,
        #background-form button {
            width: 100%;
            height: 36px;
            padding: 8px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
        }

        #background-form button {
            width: 48%;
        }

        #dark-mode-toggle {
            position: relative;
            z-index: 12;
        }

        #show-controls-button {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 12;
            padding: 10px 16px;
            background-color: #5bc0de;
            color: #333;
            border-radius: 6px;
            cursor: pointer;
            display: none;
            font-size: 16px;
            border: none;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
        }

        #show-controls-button.dark-mode {
            background-color: #337ab7;
            color: white;
            box-shadow: 2px 2px 5px rgba(255, 255, 255, 0.1);
        }

        #show-controls-button:hover {
            background-color: #46b8da;
        }

        #show-controls-button.dark-mode:hover {
            background-color: #286090;
        }

        #close-controls-button {
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.7);
            color: white;
            cursor: pointer;
            z-index: 13;
            margin-left: auto;
            align-self: flex-start;
        }

        #close-controls-button:hover {
            background-color: rgba(255, 0, 0, 0.9);
        }

        .controls-wrapper {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 11;
        }
		
		/* Added CSS for active toggle state */
		button.feature-active {
			background-color: #f0ad4e; /* Orange */
			color: white; /* Ensure text is readable */
			/* Optional: Add subtle inset shadow for a "pushed" look */
			/* box-shadow: inset 0 2px 5px rgba(0,0,0,0.2); */
			/* border-color: #eb9316; */ /* Adjust border color if needed */
		}

		/* Adjust for dark mode */
		 body.dark-mode button.feature-active {
			 background-color: #c18d3a; /* Darker orange for dark mode */
			 color: white;
		}

        .token-context-menu {
            position: fixed;
            z-index: 1000;
            min-width: 140px;
            font-size: 14px;
        }

        .token-context-menu button,
        .token-context-menu input {
            padding: 6px;
            font-size: 14px;
        }

        .dm-only {
            display: none;
        }

        body.role-dm .dm-only {
            display: block;
        }

        .dm-controls {
            display: block;
        }

        body.role-player .dm-controls {
            display: none;
        }

        #loginScreen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            z-index: 1000;
            display: block;
        }
        #loginScreen.dark-mode {
            background: rgba(0, 0, 0, 0.9);
            color: white;
        }
        #loginScreen input,
        #loginScreen select {
            width: 100%;
            padding: 8px;
            margin: 8px 0;
            font-size: 14px;
        }
        #loginScreen.hidden {
            display: none;
        }

        #notification {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            z-index: 1000;
            display: none;
            font-size: 14px;
        }

        #notification.dark-mode {
            background: rgba(255, 255, 255, 0.8);
            color: black;
        }

        #notification.error {
            background: rgba(255, 0, 0, 0.8);
        }

        #notification.error.dark-mode {
            background: rgba(255, 100, 100, 0.8);
            color: black;
        }
		
		#server-address-display {
            margin-top: 15px;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            font-size: 11px;
            line-height: 1.3;
            word-wrap: break-word; /* Ensure long addresses wrap */
        }
        #server-address-display.dark-mode {
             background-color: rgba(255, 255, 255, 0.1);
        }
        #server-address-display strong {
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="loginScreen">
        <h3>Join Session</h3>
        <label for="usernameInput">Username:</label>
        <input type="text" id="usernameInput" value="User" autocomplete="username">
        <label for="roleSelect">Role:</label>
        <select id="roleSelect">
            <option value="dm">DM</option>
            <option value="player" selected>Player</option>
        </select>
        <button id="loginButton">Join</button>
    </div>

    <!-- Notification Area -->
    <div id="notification"></div>

    <!-- Controls -->
    <div class="controls-wrapper" id="controls-wrapper">
        <div id="controls-container">
            <!-- Core Buttons -->
            <div id="core-buttons">
                <button id="dark-mode-toggle">Dark Mode</button>
                <button id="interact-button">Interact</button>
                <button id="toggle-all-visible-button" class="dm-controls">Show Map</button>
                <button id="toggle-grid-button" class="dm-controls">Hide Grid</button>
                <button id="draw-wall-button" class="dm-controls">Draw Walls</button>
                <button id="erase-wall-button" class="dm-controls">Erase Walls</button>
				<button id="reset-view-button">Reset View</button>
            </div>

            <!-- Save Controls -->
            <div id="save-controls" class="dm-controls">
                <button id="save-state-button" class="dm-controls">Save State</button>
                <button id="download-state-button" class="dm-controls">Download State</button>
                <button id="import-state-button" class="dm-controls">Import State</button>
                <input type="file" id="import-state-file" class="dm-controls" accept=".json" style="display: none;">
            </div>

            <details class="dm-controls">
                <summary>Tokens</summary>
                <form id="add-token-form">
                    <label for="token-name">Token Name:</label>
                    <input type="text" id="token-name" name="token-name" value="">
                    <label for="token-image">Token Image URL:</label>
                    <input type="text" id="token-image" name="token-image" value="">
                    <label for="token-image-file">Or Upload Image:</label>
                    <input type="file" id="token-image-file" name="token-image-file" accept="image/*">
                    <label for="token-color">Token Color:</label>
                    <input type="text" id="token-color" name="token-color">
                    <label for="token-size">Token Size:</label>
                    <select id="token-size" name="token-size">
                        <option value="1">1x1 (Medium)</option>
                        <option value="2">2x2 (Large)</option>
                        <option value="3">3x3 (Huge)</option>
                        <option value="4">4x4 (Gargantuan)</option>
                        <option value="6">6x6 (Colossal)</option>
                        <option value="8">8x8 (Titanic)</option>
                    </select>
                    <label for="token-rotation">Token Rotation (degrees):</label>
                    <input type="number" id="token-rotation" name="token-rotation" value="0" min="0" max="360" step="1">
                    <label for="token-max-hp" class="dm-only">Max HP:</label>
                    <input type="number" id="token-max-hp" name="token-max-hp" class="dm-only" value="0" min="0">
                    <label for="token-hp" class="dm-only">Current HP:</label>
                    <input type="number" id="token-hp" name="token-hp" class="dm-only" value="0" min="0">
                    <label for="token-init" class="dm-only">Initiative:</label>
                    <input type="number" id="token-init" name="token-init" class="dm-only" value="0">
                    <label for="token-ac" class="dm-only">AC:</label>
                    <input type="number" id="token-ac" name="token-ac" class="dm-only" value="0" min="0">
					<!-- Additions for Vision/Light -->
					<label for="token-sight-radius" class="dm-only">Sight Radius (cells):</label>
					<input type="number" id="token-sight-radius" name="token-sight-radius" class="dm-only" value="30" min="0">

					<label for="isLightSource" class="dm-only">Is Light Source:</label>
					<input type="checkbox" id="isLightSource" name="isLightSource" class="dm-only">
					
					<!-- This div contains the bright/dim range inputs and is hidden/shown by the script -->
					<div class="light-range-inputs dm-only" style="display: none; flex-direction: column; gap: 6px; padding-left: 10px; border-left: 1px solid #ccc;">
						<label for="token-bright-range">Bright Range (cells):</label>
						<input type="number" id="token-bright-range" name="token-bright-range" value="0" min="0">
						<label for="token-dim-range">Dim Range (cells, total):</label>
						<input type="number" id="token-dim-range" name="token-dim-range" value="0" min="0">
					</div>
                    <label for="isMinion">Is Minion:</label>
                    <input type="checkbox" id="isMinion" name="isMinion">
                    <button type="submit">Add Token</button>
                </form>
            </details>

            <details>
                <summary>Player Tokens</summary>
                <form id="player-token-form">
                    <label for="player-token-name">Token Name:</label>
                    <input type="text" id="player-token-name" name="player-token-name" value="">
                    <label for="player-token-image">Token Image URL:</label>
                    <input type="text" id="player-token-image" name="player-token-image" value="">
                    <label for="player-token-image-file">Or Upload Image:</label>
                    <input type="file" id="player-token-image-file" name="player-token-image-file" accept="image/*">
                    <label for="player-token-color">Token Color:</label>
                    <input type="text" id="player-token-color" name="player-token-color">
                    <label for="player-token-size">Token Size:</label>
                    <select id="player-token-size" name="player-token-size">
                        <option value="1">1x1 (Medium)</option>
                        <option value="2">2x2 (Large)</option>
                    </select>
                    <label for="player-token-rotation">Token Rotation (degrees):</label>
                    <input type="number" id="player-token-rotation" name="player-token-rotation" value="0" min="0" max="360" step="1">
                    <label for="playerIsMinion">Is Minion:</label>
                    <input type="checkbox" id="playerIsMinion" name="playerIsMinion">
                    <button type="submit">Add Player Token</button>
                </form>
            </details>

            <details class="dm-controls">
                <summary>Background</summary>
                <form id="background-form">
                    <label for="background-image-url">Background Image URL:</label>
                    <input type="text" id="background-image-url" name="background-image-url">
                    <label for="background-image-file">Or Upload Image:</label>
                    <input type="file" id="background-image-file" name="background-image-file" accept="image/*">
                    <div style="display: flex; gap: 4px;">
                        <button type="button" id="load-background-button">Load BG</button>
                        <button type="button" id="clear-background-button">Clear BG</button>
                    </div>
                </form>
            </details>

            <details class="dm-controls">
				<summary>Scene Size</summary>
				<div>
					<label for="grid-size-select">Scene Size:</label>      
					<select id="grid-size-select">
						<option value="micro">Micro (20x15)</option>
						<option value="small" selected>Small (40x30)</option>
						<option value="medium">Medium (70x40)</option>
						<option value="large">Large (100x55)</option>
						<option value="extra-large">Extra Large (140x70)</option>
						<option value="small-portrait">Small Portrait (30x40)</option>
						<option value="medium-portrait">Medium Portrait (40x70)</option>
						<option value="large-portrait">Large Portrait (55x100)</option>
						<option value="extra-large-portrait">Extra Large Portrait (70x140)</option>
						<option value="custom">Custom</option> <!-- New option for custom size -->
					</select>
					<!-- Custom size inputs, initially hidden -->
					<div id="custom-size-inputs" style="display: none; margin-top: 10px;">
						<label for="custom-width">Width (cells):</label>
						<input type="number" id="custom-width" min="5" max="500" value="40">
						<label for="custom-height">Height (cells):</label>
						<input type="number" id="custom-height" min="5" max="500" value="30">
						<button id="apply-custom-size">Apply Custom Size</button>
					</div>
				</div>
			</details>

            <details id="instructions-section">
                <summary>Instructions</summary>
                <div id="instructions">
                    <p><strong>Instructions:</strong></p>
                    <ul>
                        <li>DM: Add tokens/background, draw walls, manage scene.</li>
                        <li>DM: Set Max HP and Current HP for tokens; lower HP adds a red tint.</li>
                        <li>Players: Add/move your own tokens.</li>
                        <li>Tap/drag tokens to move (Interact mode).</li>
                        <li>Long-press tokens to rotate (or remove/edit for DM).</li>
                        <li>Pinch to zoom, drag to pan.</li>
                        <li>DM: Draw/Erase Walls in respective modes.</li>
                        <li>DM: Save state locally, download, or import for transfer.</li>
                        <li>Reset View to center grid.</li>
                    </ul>
                </div>
            </details>

            <div id="server-address-display">
                <strong>Server Address:</strong><br>
                <!-- Addresses will be populated here by the script -->
            </div>


            <div id="close-controls-button">X</div>
        </div>
    </div>
    <button id="show-controls-button">Show Controls</button>

    <!-- Grid Container -->
    <div id="grid-container">
        <canvas id="grid"></canvas>
    </div>

     <!-- Socket.IO Client Library - Load Relative -->
    <script src="/socket.io/socket.io.js"></script>

    <script>
		// Ensure the entire script runs after the DOM is ready
		document.addEventListener('DOMContentLoaded', () => {
			// Check if running in Electron via preload script
			const isElectron = typeof window.electronAPI !== 'undefined';
			console.log('isElectron:', isElectron);

			let serverUrl = ''; // Will be determined dynamically
			let socket = null; // Initialize socket variable
			let username = null;
			let currentRole = null;
			let isMapFullyVisible = false;

			// Suppress Autofill errors to clean up console
			console.error = (function (originalError) {
				return function (...args) {
					if (typeof args[0] === 'string' && args[0].includes('Autofill')) {
						return;
					}
					originalError.apply(console, args);
				};
			})(console.error);
			
				// --- Collision Detection Helper ---
				// Checks if a token at a proposed position (newX, newY) collides with walls or goes out of bounds
				function isCollision(newX, newY, token, walls, gridWidth, gridHeight) {
                    const tokenSize = token.size || 1; // Default to size 1 if undefined

                    // Check if any cell the token would occupy is out of bounds or a wall
                    for (let dy = 0; dy < tokenSize; dy++) {
                        for (let dx = 0; dx < tokenSize; dx++) {
                            const checkX = newX + dx;
                            const checkY = newY + dy;

                            // Check out of bounds
                            if (checkX < 0 || checkX >= gridWidth || checkY < 0 || checkY >= gridHeight) {
                                // return true; // We already clamp to bounds before calling this in client move,
                                              // but checking here is good for server-side validation.
                                              // Let's return false for out-of-bounds here, as clamping handles that.
                                              // Collision specifically means hitting a wall *within* bounds.
                                continue; // Skip this cell check if out of bounds, rely on clamping to prevent OOB moves
                            }

                            // Check for wall collision at this cell
                            // Ensure walls[checkY] exists before accessing walls[checkY][checkX]
                            if (walls[checkY] && walls[checkY][checkX] === 1) {
                                return true; // Collision detected!
                            }
                        }
                    }

                    return false; // No collision detected in the proposed new position
                }
				
				// --- Helper to check if a cell is adjacent to an owned player token ---
                // Used for highlighting walls near players
                function isAdjacentToOwnedPlayerToken(wallX, wallY, tokensData, username, currentRole) {
                    // This check is only relevant for players
                    if (currentRole !== 'player') return false;

                    // Filter for tokens owned by the current player or their minions
                    const ownedPlayerTokens = tokensData.filter(token =>
                        token.owner === username || (token.isMinion && token.parentOwner === username)
                    );

                    // Iterate through each owned player token
                    for (const playerToken of ownedPlayerTokens) {
                        const tokenSize = playerToken.size || 1;

                        // Check all cells the player token occupies and the 8 adjacent cells
                        // We iterate a 3x3 area centered around each cell the token occupies
                        for (let tokenCellY = playerToken.y; tokenCellY < playerToken.y + tokenSize; tokenCellY++) {
                             for (let tokenCellX = playerToken.x; tokenCellX < playerToken.x + tokenSize; tokenCellX++) {

                                  // Iterate through the 3x3 area around *this* token cell
                                  for (let dy = -1; dy <= 1; dy++) {
                                      for (let dx = -1; dx <= 1; dx++) {
                                          const adjacentX = tokenCellX + dx;
                                          const adjacentY = tokenCellY + dy;

                                          // Skip the cells *occupied by the token itself*
                                          if (adjacentX >= playerToken.x && adjacentX < playerToken.x + tokenSize &&
                                              adjacentY >= playerToken.y && adjacentY < playerToken.y + tokenSize) {
                                               continue;
                                          }

                                          // Check if this adjacent cell is the wall cell we're looking at
                                          if (adjacentX === wallX && adjacentY === wallY) {
                                              return true; // The wall cell is adjacent to this owned token!
                                          }
                                      }
                                  }
                             }
                        }
                    }

                    // If we checked all owned tokens and none were adjacent to this wall cell
                    return false;
                }

			// Load Socket.IO client library dynamically
			function loadSocketIO() {
				return new Promise((resolve, reject) => {
					if (typeof io !== 'undefined') {
						console.log('Socket.IO already loaded');
						resolve();
						return;
					}

					// Socket.IO client is served by the server itself at /socket.io/socket.io.js
					// This ensures we get the correct version matching the server.
					const socketIoUrl = `${window.location.protocol}//${window.location.host}/socket.io/socket.io.js`;
					const script = document.createElement('script');
					script.src = socketIoUrl;
					script.async = true;
					script.onload = () => {
						console.log('Socket.IO client library loaded');
						resolve();
					};
					script.onerror = () => {
						console.error('Failed to load Socket.IO client library from', socketIoUrl);
						showNotification('Failed to load Socket.IO. Please refresh the page.', true);
						reject(new Error('Failed to load Socket.IO'));
					};
					document.head.appendChild(script);
				});
			}


			async function determineServerUrl() {
				const serverAddressDisplay = document.getElementById('server-address-display'); // Get the element here

				// Always ensure socket.io is loaded before attempting connection or IPC
				try {
					await loadSocketIO();
				} catch (err) {
					console.error("Cannot proceed without Socket.IO:", err);
					if (serverAddressDisplay) {
                         serverAddressDisplay.innerHTML = '<strong>Server Address:</strong><br>Failed to load Socket.IO client library.';
                    }
					return; // Stop execution if socket.io fails to load
				}


				if (isElectron) {
					try {
                        // Call the IPC handler to get addresses
						const addressInfo = await window.electronAPI.getServerAddress();
						console.log('Received address info from main:', addressInfo);

                        // Use the localhost address for the Electron window's connection URL
						serverUrl = addressInfo.local; // Connect to localhost from within Electron

                        // Update the display element using the received info
						if (serverAddressDisplay) {
                             let html = '<strong>Server Addresses:</strong><br>'; // Use plural
                             // Always show localhost address for debugging/direct access
                             html += `Local: <span id="localhost-address-text">${addressInfo.local}</span>`;

                             // Check for *any* non-local addresses first
                             if (addressInfo.allLan && addressInfo.allLan.length > 0) {
                                  // Show primary LAN if it's distinct and preferred
                                  if (addressInfo.primaryLan && !addressInfo.primaryLan.includes('127.0.0.1') && addressInfo.primaryLan !== addressInfo.local) { // Ensure it's a public/LAN IP and different from localhost
                                      html += `<br>Network: <span id="primary-lan-address-text">${addressInfo.primaryLan}</span>`;
                                      // Add helper text below the preferred one
                                       html += `<br><span style="font-size: 0.9em;">(Share this with players on your network)</span>`;
                                  } else {
                                       html += `<br>Network: <span id="lan-address-text">No primary LAN address found</span>`;
                                        html += `<br><span style="font-size: 0.9em;">(Check network connection/firewall, or try other IPs below)</span>`;
                                  }

                                  // List *other* non-local addresses if there are more than the primary one (or if primary was 127.0.0.1/localhost)
                                  const otherLanAddresses = addressInfo.allLan.filter(addr => addr !== addressInfo.primaryLan && addr !== addressInfo.local);
                                  if (otherLanAddresses.length > 0) {
                                       html += `<br><span style="font-size: 0.9em;">(Other network IPs: ${otherLanAddresses.map(addr => addr.replace(/^https?:\/\//, '').replace(/:\d+$/, '')).join(', ')})</span>`;
                                  }

                             } else {
                                 // No non-local interfaces found at all
                                  html += `<br>Network: <span id="lan-address-text">No network interfaces found (check connection)</span>`;
                             }

                             serverAddressDisplay.innerHTML = html;

                        } else {
                            console.warn('Server Address display element not found.');
                        }

					} catch (error) {
						console.error('Error getting server address from main process:', error);
						// Fallback connection URL if IPC fails (shouldn't happen if preload works)
						// Note: config is not available in renderer unless exposed, using hardcoded default port
						const fallbackPort = 4000; // Assume default port if config is not available
						serverUrl = `http://localhost:${fallbackPort}`;
                        // Update display on error
						if (serverAddressDisplay) {
							serverAddressDisplay.innerHTML = '<strong>Server Address:</strong><br>';
							serverAddressDisplay.innerHTML += '<span id="lan-address-text">Error retrieving network addresses</span>';
							serverAddressDisplay.innerHTML += `<br>Localhost: ${serverUrl}`;
						} else {
                             console.warn('Server Address display element not found during error handling.');
                        }
					}
				} else {
                    // This section is for standard browser access (outside of Electron)
                    // The connection URL is simply the origin the page was loaded from.
					serverUrl = `${window.location.protocol}//${window.location.host}`;

					if (serverAddressDisplay) {
						serverAddressDisplay.innerHTML = '<strong>Connected to:</strong><br>' + serverUrl;
					}
				}

				console.log('Determined Server URL for client connection:', serverUrl);
				initializeSocket(serverUrl); // Initialize socket using the determined serverUrl
			}


			function initializeSocket(url) {
				if (typeof io === 'undefined') {
					console.error('Socket.IO client library not available.');
					showNotification('Error: Cannot connect to server (Socket.IO missing). Please reload.', true);
					return;
				}

				console.log(`Attempting to connect to Socket.IO server at: ${url}`);

				socket = io(url, {
					reconnection: true,
					reconnectionAttempts: 5,
					reconnectionDelay: 1000,
					reconnectionDelayMax: 5000,
					timeout: 20000,
					transports: ['websocket', 'polling'],
					query: { clientType: isElectron ? 'electron' : 'browser' }
				});

				// Socket event handlers
				socket.on('connect', () => {
					console.log('Socket connected:', socket.id, 'to URL:', url);
					showNotification('Connected to server!');
					document.getElementById('loginButton').disabled = false;
					document.getElementById('loginButton').textContent = 'Join';
					initializeDarkMode();
					resizeCanvas(); // Ensure canvas size is set on connect
				});

				socket.on('connect_error', (err) => {
					console.error('Socket connection error:', err.message, (err.cause ? `Cause: ${err.cause}` : ''));
					let errorMsg = 'Connection error. Trying to reconnect...';
					if (err.message.includes('xhr poll error') || err.message.includes('websocket error')) {
						errorMsg = 'Network error connecting to server. Retrying...';
					} else if (err.message === 'timeout') {
						errorMsg = 'Connection timed out. Retrying...';
					} else if (err.message.includes('Not allowed by CORS')) {
                        errorMsg = 'Connection blocked by CORS. Check server configuration.';
                    }
					showNotification(errorMsg, true);
					document.getElementById('loginButton').disabled = true;
					document.getElementById('loginButton').textContent = 'Connecting...';
					// Keep login screen hidden if already logged in, show if not
					if (!username || !currentRole) {
						document.getElementById('loginScreen').classList.remove('hidden');
					}
				});

				socket.on('disconnect', (reason) => {
					console.error('Socket disconnected:', reason);
					let msg = 'Disconnected from server.';
					if (reason === 'io server disconnect') {
						msg = 'Server closed the connection.';
					} else if (reason === 'io client disconnect') {
						msg = 'You disconnected.';
					} else {
						msg = 'Lost connection to server. Attempting to reconnect...';
					}
					if (reason !== 'io client disconnect') {
						showNotification(msg, true);
					}
					document.getElementById('loginButton').disabled = true;
					document.getElementById('loginButton').textContent = 'Disconnected';
					// Always show login screen on disconnect
					document.getElementById('loginScreen').classList.remove('hidden');
					document.body.className = ''; // Clear role class
					// Clear current user/role state on disconnect
					username = null;
					currentRole = null;

				});

				socket.on('reconnect', (attempt) => {
					console.log('Reconnected to server on attempt:', attempt);
					showNotification('Reconnected to server!');
					// Attempt to re-login with stored credentials
					if (username && currentRole) {
						console.log('Attempting to re-login after reconnect...');
						socket.emit('login', { username, role: currentRole });
					} else {
						// If no stored credentials, ensure login screen is visible
						document.getElementById('loginScreen').classList.remove('hidden');
					}
                    // Re-enable login button as reconnection is managed by socket.io
					document.getElementById('loginButton').disabled = false;
					document.getElementById('loginButton').textContent = 'Join';
				});

				socket.on('reconnect_attempt', (attempt) => {
					console.log('Reconnect attempt:', attempt);
					// Optional: Show reconnect attempt notification
					// showNotification(`Connection attempt ${attempt}...`, false);
					document.getElementById('loginButton').textContent = `Reconnecting (${attempt})...`;
				});

				socket.on('reconnect_failed', () => {
					console.error('Reconnection failed after multiple attempts');
					showNotification('Failed to reconnect. Please check the server or refresh the page.', true);
					document.getElementById('loginButton').disabled = true;
					document.getElementById('loginButton').textContent = 'Reconnect Failed';
					// Ensure login screen is visible
					document.getElementById('loginScreen').classList.remove('hidden');
				});

				socket.on('ping', () => {
					// console.log('Ping sent to server'); // Keep console clean
				});

				socket.on('pong', (latency) => {
					// console.log('Pong received, latency:', latency, 'ms'); // Keep console clean
				});

				// Game state and UI logic
				let pendingWallChanges = {};
				let tokensData = [];
				let backgroundImage = null;
				let backgroundImageUrl = '';
				let scale = 1;
				let panX = 0;
				let panY = 0;
				let walls = [];
				let isGridVisible = true; // Controls drawing grid lines, not visibility mask
				const canvas = document.getElementById('grid');
				const ctx = canvas.getContext('2d');
				const gridSize = 25; // Pixels per grid cell
				let draggedToken = null;
				let draggedTokenIndex = -1;
				let offsetX, offsetY;
				let isPanning = false;
				let isDrawing = false; // For walls
				let startX, startY; // For pan/draw start
				let currentInteractionMode = 'interact';
				let isLoading = false; // Flag to prevent interaction while loading state
				let hoveredTokenIndex = -1;
				let longPressTimeout = null;
				let longPressStartX = 0;
				let longPressStartY = 0;
				let isLongPressing = false;
				let pinchStartDistance = 0;
				let pinchStartScale = 1;
				let pinchStartCenterX = 0;
				let pinchStartCenterY = 0;
				let isContextMenuOpen = false;
				let lastDrawTime = 0;
				let glowFrame = 0; // Used for token glow animation
				let drawPending = false; // Flag to limit redraws

				// --- Visibility Variables ---
                // These Sets store string keys "{x},{y}"
				let brightLightCells = new Set(); // Cells visible in bright light from light sources
                let dimLightCells = new Set();    // Cells visible in dim light from light sources (but not bright)
                let playerVisionCells = new Set(); // Cells visible by player's own inherent vision (e.g., darkvision)
				let playerOwnedCells = new Set(); // NEW: Cells occupied by the current player's owned tokens
                let visibilityMaskCanvas = document.createElement('canvas'); // Offscreen canvas for mask
                let visibilityMaskCtx = visibilityMaskCanvas.getContext('2d');
                let maskDirty = true; // Flag to indicate if the mask needs recalculation

				const gridContainer = document.getElementById('grid-container');
				const addTokenForm = document.getElementById('add-token-form');
				const playerTokenForm = document.getElementById('player-token-form');
				const darkModeToggle = document.getElementById('dark-mode-toggle');
				const controlsContainer = document.getElementById('controls-container');
				const instructionsDiv = document.getElementById('instructions');
				const showControlsButton = document.getElementById('show-controls-button');
				const closeControlsButton = document.getElementById('close-controls-button');
				const controlsWrapper = document.getElementById('controls-wrapper');
				const gridSizeSelect = document.getElementById('grid-size-select');
				const drawWallButton = document.getElementById('draw-wall-button');
				const eraseWallButton = document.getElementById('erase-wall-button');
				const interactButton = document.getElementById('interact-button');
				const toggleGridButton = document.getElementById('toggle-grid-button');
				const toggleAllVisibleButton = document.getElementById('toggle-all-visible-button');
				console.log("toggleAllVisibleButton element:", toggleAllVisibleButton); // DEBUG LOG: Is button element found?
				const resetViewButton = document.getElementById('reset-view-button');
				const backgroundForm = document.getElementById('background-form');
				const backgroundImageUrlInput = document.getElementById('background-image-url');
				const backgroundImageFileInput = document.getElementById('background-image-file');
				const loadBackgroundButton = document.getElementById('load-background-button');
				const clearBackgroundButton = document.getElementById('clear-background-button');
				const saveStateButton = document.getElementById('save-state-button');
				const downloadStateButton = document.getElementById('download-state-button');
				const importStateButton = document.getElementById('import-state-button');
				const importStateFile = document.getElementById('import-state-file');
				const notificationDiv = document.getElementById('notification');
                const serverAddressDisplay = document.getElementById('server-address-display');


				const gridSizeOptions = {
					micro: { width: 20, height: 15 },
					small: { width: 40, height: 30 }, // Landscape
					medium: { width: 70, height: 40 },
					large: { width: 100, height: 55 },
					'extra-large': { width: 140, height: 70 },
                    // Portrait options:
                    'small-portrait': { width: 30, height: 40 },
                    'medium-portrait': { width: 40, height: 70 },
                    'large-portrait': { width: 55, height: 100 },
                    'extra-large-portrait': { width: 70, height: 140 },
				};
				
				// custom gridSize
				const customSizeInputsDiv = document.getElementById('custom-size-inputs');
				const customWidthInput = document.getElementById('custom-width');
				const customHeightInput = document.getElementById('custom-height');
				const applyCustomSizeButton = document.getElementById('apply-custom-size');

				let currentGridWidthCells = gridSizeOptions.small.width;
				let currentGridHeightCells = gridSizeOptions.small.height;

				function showNotification(message, isError = false) {
					notificationDiv.textContent = message;
					notificationDiv.classList.toggle('error', isError);
					notificationDiv.style.display = 'block';
					setTimeout(() => {
						notificationDiv.style.display = 'none';
						notificationDiv.classList.remove('error');
					}, 3000);
				}

				function normalizeWalls(wallsData, width, height) {
					// Ensure width and height are positive integers
					const validWidth = Math.max(1, Math.floor(width || 1));
					const validHeight = Math.max(1, Math.floor(height || 1));

					// Create a new 2D array filled with 0s for the target size
					const normalized = Array(validHeight).fill(null).map(() => Array(validWidth).fill(0));

					if (wallsData && Array.isArray(wallsData)) {
						// Copy existing wall data up to the bounds of the new size
						for (let y = 0; y < Math.min(validHeight, wallsData.length); y++) {
							if (wallsData[y] && Array.isArray(wallsData[y])) {
								for (let x = 0; x < Math.min(validWidth, wallsData[y].length); x++) {
									// Ensure the value is strictly 1, otherwise default to 0
									normalized[y][x] = wallsData[y][x] === 1 ? 1 : 0;
								}
							}
							// If a row is invalid or missing, the corresponding row in 'normalized' remains 0s
						}
					} else if (wallsData) {
						// If wallsData exists but isn't an array
						console.warn("normalizeWalls: wallsData is not an array. Initializing empty walls.");
					}
					// If wallsData is null/undefined, the array initialized with 0s is returned

					return normalized;
				}


				function initializeDarkMode() {
					const isDarkMode = localStorage.getItem('darkMode') === 'true';
					document.body.classList.toggle('dark-mode', isDarkMode);
					darkModeToggle.textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
					updateDarkModeStyles(isDarkMode);
					// drawGrid(); // No need to draw here, init or resizeCanvas will draw
				}

				function updateDarkModeStyles(isDarkMode) {
					document.querySelectorAll('#add-token-form, #player-token-form, #background-form, #instructions, #controls-container, #loginScreen, #show-controls-button, #notification, #server-address-display').forEach(el => {
						el.classList.toggle('dark-mode', isDarkMode);
					});
					canvas.classList.toggle('dark-mode', isDarkMode);
				}

				function imageToDataUrl(file, callback) {
					if (!file) {
						callback(null);
						return;
					}
					const reader = new FileReader();
					reader.onload = () => callback(reader.result);
					reader.onerror = () => {
						console.error('Failed to read file:', file.name);
						callback(null);
					};
					reader.readAsDataURL(file);
				}

				function preloadTokenImage(tokenData) {
					if (tokenData.imageUrl) {
						const img = new Image();
						img.src = tokenData.imageUrl;
						img.onload = () => {
							tokenData.imageObj = img;
							// Trigger mask recalculation if this token belongs to the player or is a light source
							if (currentRole === 'player' && (tokenData.owner === username || tokenData.isLightSource)) {
								maskDirty = true;
							}
							drawGrid(); // Redraw once image is loaded
						};
						img.onerror = () => {
							console.warn(`Failed to load token image: ${tokenData.imageUrl}`);
							tokenData.imageObj = null;
							drawGrid(); // Redraw even on error
						};
					} else {
						tokenData.imageObj = null;
					}
				}

				function resizeCanvas() {
					canvas.width = document.documentElement.clientWidth;
					canvas.height = document.documentElement.clientHeight;
                    // The mask canvas size needs to match the total grid pixel size
                    visibilityMaskCanvas.width = currentGridWidthCells * gridSize;
                    visibilityMaskCanvas.height = currentGridHeightCells * gridSize;
                    maskDirty = true; // Mask size changed, needs recalculation
					drawGrid(); // Redraw after resize
				}

				function loadBackgroundImage(url) {
					if (!url) {
						backgroundImage = null;
						backgroundImageUrl = '';
						drawGrid();
						return;
					}

					const img = new Image();
					img.onload = () => {
						backgroundImage = img;
						backgroundImageUrl = url;
						if (url && !url.startsWith('data:')) {
							backgroundImageUrlInput.value = url;
						} else {
							backgroundImageUrlInput.value = ''; // Clear URL field if it's a data URL
						}
						drawGrid();
					};
					img.onerror = () => {
						console.error(`Failed to load background image from: ${url}`);
						showNotification('Failed to load background image.', true);
						backgroundImage = null;
						backgroundImageUrl = '';
						drawGrid();
					};
					img.src = url;
				}

				// --- Basic Line of Sight Algorithm ---
                function isLOSClear(x0, y0, x1, y1, walls, gridWidth, gridHeight) {
                    // Check boundaries
                    if (x0 < 0 || x0 >= gridWidth || y0 < 0 || y0 >= gridHeight ||
                        x1 < 0 || x1 >= gridWidth || y1 < 0 || y1 >= gridHeight) {
                        return false; // Should not happen if iterating within grid, but safety check
                    }
                    // Starting point is never blocked
                    if (x0 === x1 && y0 === y1) return true;

                    // Implement a simple stepping algorithm (like Bresenham's on grid cells)
                    const dx = Math.abs(x1 - x0);
                    const dy = Math.abs(y1 - y0);
                    const sx = (x0 < x1) ? 1 : -1;
                    const sy = (y0 < y1) ? 1 : -1;
                    let err = dx - dy;

                    let x = x0;
                    let y = y0;

                    while (!(x === x1 && y === y1)) {
                        // Calculate next step
                        const e2 = 2 * err;
                        if (e2 > -dy) {
                            err -= dy;
                            x += sx;
                        }
                        if (e2 < dx) {
                            err += dx;
                            y += sy;
                        }

                         // Check the cell we just stepped INTO (excluding the origin cell)
                         if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
                            // If the cell contains a wall, the line of sight is blocked
                            if (walls[y] && walls[y][x] === 1) {
                                return false; // Blocked by a wall
                            }
                         }
                         // The loop continues only if the cell wasn't blocked, stepping towards the target
                    }

                    return true; // Reached the target cell without hitting a wall
                }

                // --- Calculate Visible Cells (Modified for Layered Light/Vision and Owned Cells) ---
				function calculateVisibleCells() {
					// Only calculate complex visibility for players AND when "All Visible" is OFF
					if (currentRole === 'dm' || isMapFullyVisible) {
						// DM sees everything, or All Visible is on - no masks needed
						brightLightCells.clear();
						dimLightCells.clear();
						playerVisionCells.clear();
						playerOwnedCells.clear(); // Also clear player owned cells set
						// Setting maskDirty = true here ensures buildVisibilityMask clears the mask if needed
						maskDirty = true;
						return;
					}

					// Clear previous visibility sets
					brightLightCells.clear();
					dimLightCells.clear();
					playerVisionCells.clear();
					playerOwnedCells.clear(); // Clear player owned cells set

					// Temporary sets to manage overlaps easily before finalizing
					const potentialBrightCells = new Set();
					const potentialDimCells = new Set();
					const potentialPlayerInherentCells = new Set();

					const lightSources = tokensData.filter(token => token.isLightSource);
					const playerTokens = tokensData.filter(token =>
						token.owner === username || (token.isMinion && token.parentOwner === username)
					);

					const gridWidth = currentGridWidthCells;
					const gridHeight = currentGridHeightCells;

					// --- Populate playerOwnedCells set ---
					 playerTokens.forEach(token => {
						 const tokenSize = token.size || 1;
						 for (let dy = 0; dy < tokenSize; dy++) {
							 for (let dx = 0; dx < tokenSize; dx++) {
								 const cellX = token.x + dx;
								 const cellY = token.y + dy;
								 if (cellX >= 0 && cellX < gridWidth && cellY >= 0 && cellY < gridHeight) {
									 playerOwnedCells.add(`${cellX},${cellY}`);
								 }
							 }
						 }
					 });


					// 1. Calculate light source visibility (Bright and Dim ranges)
					lightSources.forEach(sourceToken => {
						 const sx = sourceToken.x;
						 const sy = sourceToken.y;
						 // Use || 0 for safety, ensure dimRange is at least brightRange
						 const brightRange = sourceToken.brightRange || 0;
						 const dimRange = Math.max(brightRange, sourceToken.dimRange || 0); // Dim range must be >= bright range


						 if (dimRange <= 0) return; // Light source doesn't illuminate

						 // Check cells within the total dim light radius bounding box (inclusive)
						 const startCheckX = Math.max(0, sx - dimRange);
						 const endCheckX = Math.min(gridWidth - 1, sx + dimRange);
						 const startCheckY = Math.max(0, sy - dimRange);
						 const endCheckY = Math.min(gridHeight - 1, sy + dimRange);


						 for (let y = startCheckY; y <= endCheckY; y++) {
							 for (let x = startCheckX; x <= endCheckX; x++) {
								 // Using Chebyshev distance (max of horizontal/vertical distance) for radius
								 const dist = Math.max(Math.abs(x - sx), Math.abs(y - sy));

								 if (dist > dimRange) {
									 continue; // Outside total light radius
								 }

								 // Check Line of Sight from the light source's cell center to the target cell's center
								 // isLOSClear correctly checks if a wall cell is on the path.
								 if (isLOSClear(sx, sy, x, y, walls, gridWidth, gridHeight)) {
									 const cellKey = `${x},${y}`;
									 if (dist <= brightRange) {
										 potentialBrightCells.add(cellKey);
									 } else { // dist > brightRange && dist <= dimRange
										 potentialDimCells.add(cellKey);
									 }
								 }
							 }
						 }
					});


					// 2. Calculate player token inherent vision (e.g., darkvision, normal sight without external light)
					// This vision determines *which* cells a player has vision over, but doesn't dictate
					// the *visual appearance* unless combined with light sources.
					 playerTokens.forEach(playerToken => {
						 const px = playerToken.x;
						 const py = playerToken.y;
						 const sightRadius = playerToken.sightRadius || 0; // Inherent sight radius

						 if (sightRadius <= 0) return; // Token cannot see inherently

						 // Check cells within the token's inherent sight radius bounding box (inclusive)
						 const startCheckX = Math.max(0, px - sightRadius);
						 const endCheckX = Math.min(gridWidth - 1, px + sightRadius);
						 const startCheckY = Math.max(0, py - sightRadius);
						 const endCheckY = Math.min(gridHeight - 1, py + sightRadius);

						 // REVISED Player Token Inherent Vision Loop (Simpler) - Corrected loop bounds
						  for (let y = startCheckY; y <= endCheckY; y++) {
							   for (let x = startCheckX; x <= endCheckX; x++) {
									const dist = Math.max(Math.abs(x - px), Math.abs(y - py)); // Chebyshev distance

									if (dist <= sightRadius) { // Within the sight radius bounding box
										// Check Line of Sight from the player token's cell center to the target cell's center
										if (isLOSClear(px, py, x, y, walls, gridWidth, gridHeight)) {
											 potentialPlayerInherentCells.add(`${x},${y}`);
										}
									}
							   }
						  }
					 });
					// END REVISED Player Token Inherent Vision Loop


					// 3. Combine and finalize visibility sets based on light precedence
					// Bright light areas are fully visible (0% mask)
					brightLightCells = potentialBrightCells;

					// Dim light includes cells potentially in dim light *not* already in bright light
					dimLightCells = new Set();
					 potentialDimCells.forEach(cellKey => {
						 if (!brightLightCells.has(cellKey)) { // Must NOT be in bright light
							  dimLightCells.add(cellKey);
						 }
					 });

					// Player vision includes cells potentially seen by player sight *not* in bright or dim light
					playerVisionCells = new Set();
					potentialPlayerInherentCells.forEach(cellKey => {
						 if (!brightLightCells.has(cellKey) && !dimLightCells.has(cellKey)) {
							 playerVisionCells.add(cellKey);
						 }
					});

					 maskDirty = true; // Mask needs to be rebuilt based on new visibility sets
				}

                // --- Build the Visibility Mask Canvas (Corrected Logic & Fixed Typos) ---
                // This function creates a mask canvas where each pixel's alpha determines visual appearance:
                // alpha = 0   -> Fully Visible (Bright Light OR Player's OWN Token Location OR Adjacent Wall)
                // alpha = 0.6 -> Dimmed (Dim Light)
                // alpha = 1   -> Solid Black Fog (Not Visible at all OR Player Inherent Vision Alone)
                                            // --- Build the Visibility Mask Canvas ---
				// This function creates a mask canvas where each pixel's alpha determines visual appearance:
				// alpha = 0   -> Fully Visible (Bright Light OR Player's OWN Token Location OR Adjacent Wall revealed by vision/light)
				// alpha = 0.6 -> Dimmed (Dim Light)
				// alpha = 1   -> Solid Black Fog (Not Visible at all)
				function buildVisibilityMask() {
					// No mask needed for DM or when 'Show Map' is on
					if (currentRole === 'dm' || isMapFullyVisible) {
						visibilityMaskCtx.clearRect(0, 0, visibilityMaskCanvas.width, visibilityMaskCanvas.height);
						maskDirty = false; // Mask is now clear (effectively off)
						return;
					}

					 if (!maskDirty) return; // Only rebuild if necessary

					 const gridPixelWidth = currentGridWidthCells * gridSize;
					 const gridPixelHeight = currentGridHeightCells * gridSize;

					 visibilityMaskCanvas.width = gridPixelWidth;
					 visibilityMaskCanvas.height = gridPixelHeight;
					 visibilityMaskCtx.clearRect(0, 0, gridPixelWidth, gridPixelHeight); // Start with a fully transparent canvas

					 const dimmingOpacity = 0.6; // Opacity for the dim areas (60% black fog overlay)


					 // Iterate through all grid cells and draw the appropriate mask pixel
					 for (let y = 0; y < currentGridHeightCells; y++) {
						 for (let x = 0; x < currentGridWidthCells; x++) {
							 const cellKey = `${x},${y}`;
							 let maskOpacity = 1; // Default to full fog (opaque black)

							 // Determine base opacity based on light/vision precedence
							 // Bright Light > Dim Light > Full Fog (for anything else)
							 if (brightLightCells.has(cellKey)) {
								 maskOpacity = 0; // Fully transparent in bright light
							 }
							 else if (dimLightCells.has(cellKey)) {
								 maskOpacity = dimmingOpacity; // Semi-transparent in dim light
							 }
							 // Note: playerVisionCells themselves don't reduce mask opacity, they just make tokens knowable.


							 // Override mask opacity if this cell is occupied by the CURRENT PLAYER's token(s)
							 // This ensures the owned token's space is always fully clear visually.
							 if (playerOwnedCells.has(cellKey)) {
								  maskOpacity = 0; // Make player's *own* token squares fully clear, regardless of other lighting/vision
							 }

							 // Check if this cell is a wall AND it is knowable (visible by vision/light or owned token)
							 // If so, make the mask transparent to reveal the underlying wall (drawn dimmed in drawGrid)
							 // unless it's already fully transparent (e.g., by bright light or owned cell override).
							 // We check `walls[y] && walls[y][x] === 1` to ensure it's actually a wall cell.
							 // We check `isCellKnowable(x, y)` to see if the *player's vision/light* reveals this wall cell.
							 // Note: Player-owned cells already result in maskOpacity = 0.
							 if (maskOpacity > 0 && // Only modify if not already clear
								 walls[y] && walls[y][x] === 1 &&
								 isCellKnowable(x, y)) // Check if the wall cell itself is knowable
							 {
								 maskOpacity = 0; // Make the mask clear for wall cells that are knowable
							 }


							 // Draw the mask pixel with the determined opacity (0=clear, dimmingOpacity=dim, 1=fog)
							 visibilityMaskCtx.fillStyle = `rgba(0, 0, 0, ${maskOpacity})`;
							 visibilityMaskCtx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
						 }
					 }

					 maskDirty = false; // Mask is now up-to-date
				}

				// --- Main Drawing Function ---
				function drawGrid() {
					// Prevent multiple redraw calls queued up
					if (drawPending) return;
					drawPending = true;

					// Request the next animation frame
					requestAnimationFrame(() => {
						const now = performance.now();
						// Update glow animation frame based on time for animations
						glowFrame = now / 1000;

						// Clear the entire canvas to start fresh for this frame
						// This is done in the identity transform space (before pan/zoom)
						ctx.clearRect(0, 0, canvas.width, canvas.height);

						// --- Apply Main Pan and Scale Transformations ---
						// Save the canvas state *before* applying pan and scale.
						// This saved state represents the identity transform and no clipping.
						ctx.save();
						ctx.translate(panX, panY); // Apply user pan (shifts the canvas origin)
						ctx.scale(scale, scale); // Apply user zoom (scales subsequent drawing operations)

						// Calculate the total size of the grid area in pixels at a 1:1 scale.
						// This is the target area in the *transformed space* that we want to draw within.
						const gridPixelWidth = currentGridWidthCells * gridSize;
						const gridPixelHeight = currentGridHeightCells * gridSize;

						// --- Set Clipping Region to the Grid Area ---
						// Define a rectangle for the clipping path.
						// The coordinates (0,0) and dimensions (gridPixelWidth, gridPixelHeight)
						// are interpreted in the *current transformed coordinate system*.
						// This rectangle represents the visual bounds of the grid on the screen.
						ctx.beginPath(); // Start a new path for the clipping shape
						ctx.rect(0, 0, gridPixelWidth, gridPixelHeight); // Define the rectangle shape
						ctx.clip(); // Apply this path as the current clipping path.
									// ONLY drawing operations that occur *after* this `clip()` call
									// will be restricted to the area defined by this path.
									// The clipping path itself is also subject to the current transform.


						// --- Draw Content Within the Clipped Grid Area ---

						// 1. Draw Background Image (will be clipped to the grid area)
						//    This uses the 'cover' logic to scale the image to fit the grid aspect ratio
						if (backgroundImage && backgroundImage.complete && backgroundImage.naturalWidth !== 0) {
							const gridAspectRatio = gridPixelWidth / gridPixelHeight;
							const imageAspectRatio = backgroundImage.width / backgroundImage.height;

							let drawWidth, drawHeight, offsetX, offsetY;

							// Calculate dimensions to make the image "cover" the entire grid area.
							// One dimension will match the grid, the other will be larger or equal.
							if (imageAspectRatio > gridAspectRatio) {
								// Image is proportionally wider than grid: Scale height to match grid, width will be larger.
								drawHeight = gridPixelHeight;
								drawWidth = drawHeight * imageAspectRatio;
							} else {
								// Image is proportionally taller or same as grid: Scale width to match grid, height will be larger or equal.
								drawWidth = gridPixelWidth;
								drawHeight = drawWidth / imageAspectRatio;
							}

							// Calculate offset to center the scaled image within the grid area (0,0 to gridPixelWidth, gridPixelHeight).
							// If the image dimension is larger than the grid, the offset will be negative, positioning the image partially outside the clip area, which gets cropped.
							offsetX = (gridPixelWidth - drawWidth) / 2;
							offsetY = (gridPixelHeight - drawHeight) / 2;

							// Draw the image. Its destination rectangle (offsetX, offsetY, drawWidth, drawHeight)
							// is relative to the transformed origin (which is the top-left of the grid area in this transformed space).
							// The image will be automatically clipped by the `ctx.clip()` applied above.
							ctx.drawImage(backgroundImage, offsetX, offsetY, drawWidth, drawHeight);
						}

						// 2. Draw Grid Lines (will be clipped)
						//    These are drawn after the background layer.
						if (isGridVisible) {
							const gridColor = document.body.classList.contains('dark-mode') ? 'rgba(85, 85, 85, 0.7)' : 'rgba(204, 204, 204, 0.7)';
							ctx.strokeStyle = gridColor;
							// Line width scales inversely with zoom to maintain apparent thickness
							ctx.lineWidth = 1 / scale;

							for (let i = 0; i <= currentGridWidthCells; i++) {
								const x = i * gridSize;
								ctx.beginPath();
								// Drawing coordinates are relative to the transformed origin (top-left of grid area)
								ctx.moveTo(x, 0);
								ctx.lineTo(x, gridPixelHeight);
								ctx.stroke();
							}
							for (let i = 0; i <= currentGridHeightCells; i++) {
								const y = i * gridSize;
								ctx.beginPath();
								// Drawing coordinates are relative to the transformed origin (top-left of grid area)
								ctx.moveTo(0, y);
								ctx.lineTo(gridPixelWidth, y);
								ctx.stroke();
							}
						}

						// 3. Draw Walls (will be clipped)
						//    These are drawn after grid lines, before tokens.
						// --- MODIFIED WALL DRAWING FOR ADJACENCY HIGHLIGHT ---
						let wallColorBase = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.8)' : 'rgba(0, 0, 0, 0.8)'; // Standard wall color/opacity
						let wallColorAdjacent = document.body.classList.contains('dark-mode') ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 255, 0.6)'; // Slightly less opaque for adjacent
						const isPlayer = currentRole === 'player';

						for (let y = 0; y < currentGridHeightCells; y++) {
							for (let x = 0; x < currentGridWidthCells; x++) {
								if (walls[y] && walls[y][x] === 1) {
									// Determine color/opacity based on role and adjacency
									let wallFillColor = wallColorBase;
									// Only highlight adjacent walls for players when FoW is active ('Show Map' is OFF)
									if (isPlayer && !isMapFullyVisible && isAdjacentToOwnedPlayerToken(x, y, tokensData, username, currentRole)) {
										 wallFillColor = wallColorAdjacent;
									}

									ctx.fillStyle = wallFillColor;
									// Coordinates are relative to transformed origin (top-left of grid area)
									ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
								}
							}
						}

						// --- START FOW CALCULATION FOR PLAYERS ---
						// Calculate visibility sets *before* drawing tokens or names for players under FoW
						if (currentRole === 'player' && !isMapFullyVisible) {
							// Only calculate if maskDirty is true, otherwise reuse previous calculation
							if (maskDirty) { // We flag maskDirty whenever visibility criteria change
								calculateVisibleCells(); // This updates brightLightCells, dimLightCells, playerVisionCells, playerOwnedCells
							}
						} else {
							// Clear sets if not player or Show Map is on, ensuring isTokenKnowable works correctly
							brightLightCells.clear();
							dimLightCells.clear();
							playerVisionCells.clear();
							playerOwnedCells.clear();
						}
						// --- END FOW CALCULATION ---


						// --- Draw Tokens (will be clipped) ---
						//    These are drawn after walls.
						tokensData.forEach((tokenData, index) => {
							// Decide if the token should be drawn for this client
							let shouldDrawToken = false;
							const isOwner = tokenData.owner === username || (tokenData.isMinion && tokenData.parentOwner === username);

							if (currentRole === 'dm') {
								shouldDrawToken = true; // DM sees all tokens
							} else { // Player role
								if (isMapFullyVisible) {
									shouldDrawToken = true; // Player sees all tokens if DM has 'Show Map' on
								} else { // Standard player FoW is active (visibility sets populated above)
									// Player sees tokens they own, OR tokens that are knowable through FoW/light calculation
									shouldDrawToken = isOwner || isTokenKnowable(tokenData); // Use the calculated isTokenKnowable here
								}
							}

							if (shouldDrawToken) {
								// Save the current state *including* the main pan/zoom and the grid clipping path
								ctx.save(); // <--- Moved ctx.save() inside the draw condition

								const tokenSize = tokenData.size || 1;
								// Calculate token top-left position relative to transformed origin (top-left of grid area)
								const x = tokenData.x * gridSize;
								const y = tokenData.y * gridSize;
								const width = gridSize * tokenSize;
								const height = gridSize * tokenSize;
								const rotation = (tokenData.rotation || 0) * Math.PI / 180;
								const isSelected = index === hoveredTokenIndex || index === draggedTokenIndex;
								let hpPercentage = 1;
								const isLowHealth = tokenData.maxHP > 0 && tokenData.hp !== undefined && tokenData.hp / tokenData.maxHP < 0.25;

								// Translate origin to the token's center, relative to the current transformed space (the grid area)
								ctx.translate(x + width / 2, y + height / 2);
								ctx.rotate(rotation);

								// Drawing coordinates are relative to the token's center
								const drawX = -width / 2;
								const drawY = -height / 2;

								// --- DRAW GLOW EFFECT FIRST (if applicable) ---
								// ... (Your existing glow drawing logic using drawX, drawY, width, height - uses current transform & clip) ...
								if (isSelected || isLowHealth) {
									const glowStrength = Math.sin(glowFrame * Math.PI * 2) * 0.2 + 0.8;
									const sizeFactor = Math.min(1 / tokenSize, 1);
									const glowMultiplier = 1 + sizeFactor * 0.8;

									ctx.shadowColor = isSelected
										? (document.body.classList.contains('dark-mode') ? 'rgba(150, 150, 255, 0.8)' : 'rgba(0, 0, 255, 0.6)')
										: 'rgba(255, 50, 50, 0.8)';

									ctx.shadowBlur = 50 * glowStrength * glowMultiplier / scale; // Scale blur inversely with zoom

									const baseScale = 1.0;
									const pulseScale = baseScale + (glowStrength * 0.08 * sizeFactor);
									ctx.scale(pulseScale, pulseScale);

									ctx.fillStyle = ctx.shadowColor;
									if (tokenSize === 1) { ctx.beginPath(); ctx.arc(0, 0, width / 2, 0, Math.PI * 2); ctx.fill(); }
									else { const radius = width * 0.15; ctx.beginPath(); ctx.moveTo(drawX + radius, drawY); ctx.lineTo(drawX + width - radius, drawY); ctx.quadraticCurveTo(drawX + width, drawY, drawX + width, drawY + radius); ctx.lineTo(drawX + width, drawY + height - radius); ctx.quadraticCurveTo(drawX + width, drawY + height, drawX + width - radius, drawY + height); ctx.lineTo(drawX + radius, drawY + height); ctx.quadraticCurveTo(drawX, drawY + height, drawX, drawY + height - radius); ctx.lineTo(drawX, drawY + radius); ctx.quadraticCurveTo(drawX, drawY, drawX + radius, drawY); ctx.closePath(); ctx.fill(); }

									ctx.shadowBlur = 0;
									ctx.shadowColor = 'transparent';
								}

								// Inside drawGrid -> tokensData.forEach -> if (shouldDrawToken)
								// --- DRAW TOKEN IMAGE/COLOR (ON TOP) ---
								if (tokenData.imageObj && tokenData.imageObj.complete && tokenData.imageObj.naturalWidth !== 0) {
									// Draw image (already defines its own area implicitly)
									ctx.drawImage(tokenData.imageObj, drawX, drawY, width, height);
								} else {
									// *** FIX START ***
									// Explicitly define the path for the color fill.
									// Use the same drawX, drawY, width, height calculated earlier,
									// which are relative to the token's translated center.
									ctx.beginPath(); // Start a new path just for this fill operation
									ctx.rect(drawX, drawY, width, height); // Define the rectangle path
									// *** FIX END ***

									// Now set color and fill the *just defined* path
									ctx.fillStyle = tokenData.backgroundColor || 'grey';
									ctx.fill(); // Fills the rectangle defined above
								}

								// --- APPLY RED TINT (ON TOP of image/color) ---
								if (tokenData.maxHP > 0 && tokenData.hp !== undefined) {
									 hpPercentage = Math.max(0, Math.min(1, tokenData.hp / tokenData.maxHP)); const redTint = 1 - hpPercentage;
									 if (redTint > 0) {
										 ctx.globalCompositeOperation = 'source-atop';
										  if (tokenSize === 1) { ctx.beginPath(); ctx.arc(0, 0, width / 2, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 0, 0, ${redTint * 0.5})`; ctx.fill(); }
										  else { const radius = width * 0.15; ctx.beginPath(); ctx.moveTo(drawX + radius, drawY); ctx.lineTo(drawX + width - radius, drawY); ctx.quadraticCurveTo(drawX + width, drawY, drawX + width, drawY + radius); ctx.lineTo(drawX + width, drawY + height - radius); ctx.quadraticCurveTo(drawX + width, drawY + height, drawX + width - radius, drawY + height); ctx.lineTo(drawX + radius, drawY + height); ctx.quadraticCurveTo(drawX, drawY + height, drawX, drawY + height - radius); ctx.lineTo(drawX, drawY + radius); ctx.quadraticCurveTo(drawX, drawY, drawX + radius, drawY); ctx.closePath(); ctx.fillStyle = `rgba(255, 0, 0, ${redTint * 0.5})`; ctx.fill(); }
										 ctx.globalCompositeOperation = 'source-over';
									 }
								}

								// --- DRAW SELECTION OUTLINE (ON TOP of everything) ---
								if (isSelected) {
									 ctx.strokeStyle = document.body.classList.contains('dark-mode') ? 'cyan' : 'blue';
									 ctx.lineWidth = 2 / scale;
									  if (tokenSize === 1) { ctx.beginPath(); ctx.arc(0, 0, width / 2, 0, Math.PI * 2); ctx.stroke(); }
									  else { const radius = width * 0.15; ctx.beginPath(); ctx.moveTo(drawX + radius, drawY); ctx.lineTo(drawX + width - radius, drawY); ctx.quadraticCurveTo(drawX + width, drawY, drawX + width, drawY + radius); ctx.lineTo(drawX + width, drawY + height - radius); ctx.quadraticCurveTo(drawX + width, drawY + height, drawX + width - radius, drawY + height); ctx.lineTo(drawX + radius, drawY + height); ctx.quadraticCurveTo(drawX, drawY + height, drawX, drawY + height - radius); ctx.lineTo(drawX, drawY + radius); ctx.quadraticCurveTo(drawX, drawY, drawX + radius, drawY); ctx.closePath(); ctx.stroke(); }
								}

								ctx.restore(); // Restore the state saved just for this token
							}
							// If !shouldDrawToken, nothing is drawn and ctx.save()/ctx.restore() were skipped, which is correct.
						});


						// --- Apply Visibility Mask (will be clipped) ---
						// Only apply mask for players. It will be clipped by the grid area clip path.
						if (currentRole === 'player' && !isMapFullyVisible) { // Only apply mask when player and Show Map is OFF
							 // Recalculate and build mask if needed (maskDirty checked at the start of the player block)
							 if (maskDirty) {
								 buildVisibilityMask(); // Builds a mask with varying transparency using the sets calculated above
							 }
							 // Draw the mask canvas over the grid area (0,0 to gridPixelWidth, gridPixelHeight)
							 // It will be clipped by the grid area clip path.
							 ctx.drawImage(visibilityMaskCanvas, 0, 0, gridPixelWidth, gridPixelHeight);
						} else {
							 // DM or Player with Show Map ON: ensure mask is effectively off (cleared in buildVisibilityMask)
							 maskDirty = false; // Ensure flag is false when mask isn't being used/drawn
						}


						// Restore the canvas state saved at the beginning.
						// This removes the main pan/zoom transformations and the grid clipping path.
						ctx.restore();


						// Update token names (DOM elements, drawn outside the canvas)
						// This happens after the canvas drawing is complete.
						// Token names are *not* subject to canvas clipping, they are separate HTML elements.
						updateTokenNames();
						drawPending = false;

						// Continue drawing loop
						// Request the next animation frame to keep the canvas updated
						requestAnimationFrame(drawGrid);
					});
				}

                // --- Helper to check if any cell a token occupies is in Bright Light ---
                 function isTokenInBrightLight(token) {
                      const tokenSize = token.size || 1;
                      const gridWidth = currentGridWidthCells;
                      const gridHeight = currentGridHeightCells;
                      for (let dy = 0; dy < tokenSize; dy++) {
                          for (let dx = 0; dx < tokenSize; dx++) {
                              const cellX = token.x + dx;
                              const cellY = token.y + dy;
                              // Check boundaries and if the cell key is in the bright set
                              if (cellX >= 0 && cellX < gridWidth && cellY >= 0 && cellY < gridHeight) {
                                  const cellKey = `${cellX},${cellY}`;
                                  if (brightLightCells.has(cellKey)) {
                                      return true; // Found at least one bright cell
                                  }
                              }
                          }
                      }
                      return false; // No occupied cell is in bright light
                 }


				// --- Helper to check if a cell is visible (knowable) to the current player ---
				// This function determines if a cell is *knowable* (can see tokens/walls there), not its visual brightness.
                // Used for interaction checks and general token knowability.
				// --- Helper to check if a cell is visible (knowable) under FOW rules ---
				// Does NOT consider DM role or isMapFullyVisible here.
				// Assumes necessary visibility sets (brightLightCells, dimLightCells, playerVisionCells, playerOwnedCells) are globally available.
				function isCellKnowable(x, y) {
					const cellKey = `${x},${y}`;
					// A cell is *knowable* if it's in bright, dim, OR player vision areas, OR is occupied by a player's own token.
					return brightLightCells.has(cellKey) || dimLightCells.has(cellKey) || playerVisionCells.has(cellKey) || playerOwnedCells.has(cellKey);
				}

                // --- Helper to check if *any part* of a token is knowable under FOW rules ---
				// Does NOT consider DM role or isMapFullyVisible here.
				 function isTokenKnowable(token) {
					const tokenSize = token.size || 1;
					 for (let dy = 0; dy < tokenSize; dy++) {
						 for (let dx = 0; dx < tokenSize; dx++) {
							 const cellX = token.x + dx;
							 const cellY = token.y + dy;
							 // Check boundaries before calling isCellKnowable
							 if (cellX >= 0 && cellX < currentGridWidthCells && cellY >= 0 && cellY < currentGridHeightCells) {
								if (isCellKnowable(cellX, cellY)) {
									return true; // Found at least one knowable cell
								}
							}
						}
					}
					return false; // No occupied cell is knowable
				}


				function updateTokenNames() {
					// Remove existing token names
					document.querySelectorAll('.token-name').forEach(el => el.remove());

					const minDistance = 40; // Minimum pixel distance between names

					const visibleNames = [];

					// Determine which tokens' names should potentially be displayed
					tokensData.forEach(tokenData => {
						// Decide if this token's name should be visible to the *current client*
						let shouldDisplayName = false;
						const isOwner = tokenData.owner === username || (tokenData.isMinion && tokenData.parentOwner === username);

						if (currentRole === 'dm') {
							shouldDisplayName = true; // DM sees all names
						} else { // Player role
							if (isMapFullyVisible) { // If DM enabled All Visible
								shouldDisplayName = true; // Player sees all names if DM has 'Show Map' on
							} else { // Standard player FoW is active (visibility sets populated in drawGrid)
								// Player sees their OWN token name OR other tokens' names if knowable
								shouldDisplayName = isOwner || isTokenInBrightLight(tokenData); // Use isTokenInBrightLight here!
							}
						}

						// If the name should be displayed based on the rules above
						if (shouldDisplayName) {
							// Calculate screen position - use token center X and token top Y
							const tokenSize = tokenData.size || 1;
							const canvasX_center = (tokenData.x + tokenSize / 2) * gridSize; // Canvas X center of the token
							const canvasY_top = tokenData.y * gridSize; // Canvas Y top of the token bounding box

							const screenX_center = canvasX_center * scale + panX;
							const screenY_top = canvasY_top * scale + panY;

							// Check if this is the currently hovered or dragged token for priority
							const originalIndex = tokensData.findIndex(t => t.id === tokenData.id);
							const isImportant = originalIndex === hoveredTokenIndex || originalIndex === draggedTokenIndex;
							const priority = isImportant ? 2 : 0; // Priority 2 for important, 0 for others


							// Apply overlap check *only* if we are NOT showing all names (i.e., under standard FoW rules) AND below zoom threshold
							let canShow = true;
							// Overlap check applies if player, FoW is ON (Map Visible OFF), AND zoom is below threshold (using 1.0 as threshold)
							// This prevents name clutter in dense areas under FoW unless zoomed in
							// Also skip overlap check for important tokens (priority 2)
							if (currentRole === 'player' && !isMapFullyVisible && scale < 1.0 && !isImportant) { // Corrected condition here
								 for (const visible of visibleNames) {
									  // Skip overlap check against other important tokens
									  if (visible.priority === 2) continue;

									  const dx_pixels = Math.abs(screenX_center - visible.screenX);
									  const dy_pixels = Math.abs(screenY_top - visible.screenY_top);
									  const distance = Math.sqrt(dx_pixels * dx_pixels + dy_pixels * dy_pixels);
									  // Use minDistance scaled inversely by current zoom level
									  if (distance < minDistance / scale) { // Divide minDistance by scale
										 canShow = false;
										 break;
									  }
								 }
							}

							// If allowed to show name (either by rule or passing overlap check)
							if (canShow) {
								// Add to list with calculated priority
								visibleNames.push({ tokenData, screenX: screenX_center, screenY_top: screenY_top, priority: priority });
							}
						}
					});

					// --- Sort the names before creating and appending the divs ---
					// Primary sort: Priority (higher value means higher priority, should be added later in DOM to appear on top)
					// Secondary sort: Screen Y position descending (labels for lower tokens should be added later)
					// Tertiary sort: Screen X position ascending (labels for lefter elements should be added earlier)
					visibleNames.sort((a, b) => {
						// Primary sort: Priority (hovered/dragged highest, put later in sort)
						if (b.priority !== a.priority) {
							return b.priority - a.priority; // Descending priority
						}
						// Secondary sort: Screen Y position (descending, so lower elements appear later/on top in DOM)
						if (b.screenY_top !== a.screenY_top) {
							 return b.screenY_top - a.screenY_top; // Descending Y
						}
						// Tertiary sort: Screen X position (ascending, so lefter elements draw earlier/behind)
						 return a.screenX - b.screenX; // Ascending X
					});


					// Create and position name divs for the visible names
					visibleNames.forEach(({ tokenData, screenX, screenY_top, priority }) => { // Include priority in destructuring
						const nameDiv = document.createElement('div');
						nameDiv.classList.add('token-name');

						// Set text content based on role and token data
						if (currentRole === 'dm') {
							const hpDisplay = tokenData.maxHP > 0 && tokenData.hp !== undefined ? `${tokenData.hp}/${tokenData.maxHP}` : (tokenData.hp !== undefined ? tokenData.hp : '--/--');
							const initDisplay = tokenData.initiative !== undefined ? tokenData.initiative : '--';
							const acDisplay = tokenData.ac !== undefined ? tokenData.ac : '--';
							const lightDisplay = tokenData.isLightSource ? `Light: ${tokenData.brightRange || 0}/${tokenData.dimRange || 0}` : '';
							if (lightDisplay) {
								nameDiv.innerHTML = `${tokenData.name} (HP: ${hpDisplay}, Init: ${initDisplay}, AC: ${acDisplay}) <br> ${lightDisplay}`;
								nameDiv.style.lineHeight = '1.2';
							} else {
								nameDiv.textContent = `${tokenData.name} (HP: ${hpDisplay}, Init: ${initDisplay}, AC: ${acDisplay})`;
							}
						} else {
							// Players only see the basic name
							nameDiv.textContent = tokenData.name;
						}
						nameDiv.dataset.tokenId = tokenData.id;

						// Append first to measure (needed for offsetWidth/offsetHeight if calculating true center)
						document.body.appendChild(nameDiv);

						// Position the name div
						// Set left to the token's screen center X
						 nameDiv.style.left = `${screenX}px`;
						// Set top to the token's screen top Y minus a small offset.
						// The CSS transform translate(-50%, -100%) will then correctly
						// position the name's bottom-center at (screenX, screenY_top - 5).
						 nameDiv.style.top = `${screenY_top - 5}px`; // 5px padding above token


						// Add hovered style and set z-index
						const originalIndex = tokensData.findIndex(t => t.id === tokenData.id);
						const isCurrentlySelected = originalIndex === hoveredTokenIndex || originalIndex === draggedTokenIndex;

						// Use priority for z-index: Higher priority tokens (selected/dragged) get higher z-index (100). Others get 10.
						nameDiv.style.zIndex = priority === 2 ? '100' : '10';


						if (isCurrentlySelected) {
							nameDiv.classList.add('hovered'); // Apply hovered style
						} else {
							// Dim non-selected names *only when FoW is active for players*
							// If DM, or Player with Show Map ON, keep opacity 1.0
							if (currentRole === 'player' && !isMapFullyVisible) {
								 nameDiv.style.opacity = '0.7'; // Dim non-hovered/non-selected names under player FoW
							} else {
								 nameDiv.style.opacity = '1.0'; // Full opacity when FoW is off (DM or Player + All Visible)
							}
						}
					});
				}

				function getTokenAtPosition(canvasX, canvasY) {
					// Filter tokens to only consider those that are knowable and interactable
					// Interaction requires ownership/DM role AND visibility/knowability
					const interactiveTokens = tokensData.filter(token => {
						 const isOwner = token.owner === username || (token.isMinion && token.parentOwner === username);

						 if (currentRole === 'dm') return true; // DM can interact with any token regardless of visibility

						 // Player can only interact with owned tokens...
						 if (isOwner) {
							 // ...and only if they are visible on the map for the player.
							 // If DM has 'Show Map' on, owned tokens are always interactive.
							 if (isMapFullyVisible) return true;
							 // If FOW is active ('Show Map' is off), player can only interact with owned tokens if they are knowable by their vision/light.
							 return isTokenKnowable(token); // Check based on player vision/light/walls
						 }

						 return false; // Player cannot interact with non-owned tokens
					});


					for (let i = interactiveTokens.length - 1; i >= 0; i--) {
						const tokenData = interactiveTokens[i];
						const originalIndex = tokensData.findIndex(t => t.id === tokenData.id); // Get original index
						const tokenSize = tokenData.size || 1;
						const tokenPixelWidth = gridSize * tokenSize;
						const tokenPixelHeight = gridSize * tokenSize;
						const tokenX = tokenData.x * gridSize;
						const tokenY = tokenData.y * gridSize;

						// Simple bounding box check first
						if (
							canvasX >= tokenX &&
							canvasX < tokenX + tokenPixelWidth &&
							canvasY >= tokenY &&
							canvasY < tokenY + tokenPixelHeight
						) {
							// The filter `interactiveTokens` already ensures knowability and ownership/role for interaction
							return { token: tokenData, index: originalIndex };
						}
					}
					return null; // No interactive token found at position
				}

				function handleInteractionStart(clientX, clientY) {
					if (isLoading || isContextMenuOpen) return; // Prevent interaction while loading or menu is open

					const rect = canvas.getBoundingClientRect();
					const canvasX = (clientX - rect.left - panX) / scale;
					const canvasY = (clientY - rect.top - panY) / scale;

					// console.log(`Interaction start at canvasX: ${canvasX}, canvasY: ${canvasY}`); // Verbose log

					if (currentInteractionMode === 'interact') {
						const tokenInfo = getTokenAtPosition(canvasX, canvasY);
						// The filter in getTokenAtPosition already handles DM/ownership checks and knowability
						if (tokenInfo) {
							draggedToken = tokenInfo.token;
							draggedTokenIndex = tokenInfo.index;
							// Calculate offset relative to token's top-left corner of its bounding box
							offsetX = canvasX - draggedToken.x * gridSize;
							offsetY = canvasY - draggedToken.y * gridSize;
							// console.log(`Dragging token: ${draggedToken.name}, offsetX: ${offsetX}, offsetY: ${offsetY}`); // Verbose log
							drawGrid();
						} else {
							// Start panning if no interactive token is clicked at this mode
							isPanning = true;
							startX = clientX;
							startY = clientY;
							// console.log('Starting panning'); // Verbose log
						}
					} else if (currentRole === 'dm' && (currentInteractionMode === 'draw' || currentInteractionMode === 'erase')) {
						// Only DM can draw/erase walls
						const gridX = Math.floor(canvasX / gridSize);
						const gridY = Math.floor(canvasY / gridSize);
						if (gridX >= 0 && gridX < currentGridWidthCells && gridY >= 0 && gridY < currentGridHeightCells) {
							// Ensure wall array is initialized for the row
							if (!walls[gridY]) walls[gridY] = Array(currentGridWidthCells).fill(0);
							// Only make a change if the state is different
							const newState = currentInteractionMode === 'draw' ? 1 : 0;
							if (walls[gridY][gridX] !== newState) {
                                pendingWallChanges[`${gridY}_${gridX}`] = newState;
							    walls[gridY][gridX] = newState;
                                maskDirty = true; // Wall changed, need mask update
							    drawGrid(); // Redraw immediately for drawing feedback
                            }
                             isDrawing = true; // Set drawing flag
                             startX = gridX; // Store start cell for potential line drawing (though current impl is pixel by pixel)
                             startY = gridY;
						}
					}
				}

								// --- Context Menu Logic ---
								// --- Context Menu Logic ---
				function showContextMenu(clientX, clientY, tokenIndex) {
					// Remove any existing context menus
					document.querySelectorAll('.token-context-menu').forEach(m => m.remove());
					// isContextMenuOpen is set to true later, after the menu is added

					const menu = document.createElement('div');
					menu.classList.add('token-context-menu');
					// Position the menu - ensure it doesn't go offscreen (basic check)
					// Initial position before size check
					let menuX = clientX;
					let menuY = clientY;

					// Add base styles before appending to measure
					if (document.body.classList.contains('dark-mode')) {
						menu.style.backgroundColor = '#222';
						menu.style.border = '1px solid white';
						menu.style.color = 'white';
					} else {
						menu.style.backgroundColor = 'white';
						menu.style.border = '1px solid black';
						menu.style.color = 'black';
					}
                    menu.style.padding = '8px';
					menu.style.zIndex = '1000'; // High z-index to be on top
					menu.style.borderRadius = '4px';
                    menu.style.boxShadow = '2px 2px 8px rgba(0,0,0,0.3)'; // Add shadow
                    menu.style.display = 'flex'; // Use flexbox for internal layout
                    menu.style.flexDirection = 'column';
                    menu.style.gap = '6px'; // Space between elements


					const token = tokensData[tokenIndex];
                    if (!token) {
                         isContextMenuOpen = false; // Reset flag if token not found
                         return;
                    }


					// Build menu content based on role and token ownership
					// Start with the token name
					let menuHTML = `<div style="font-weight: bold; margin-bottom: 2px; text-align: center;">${token.name}</div>`;

					// --- Add role-specific content inputs/displays ---
					if (currentRole === 'dm') {
						// Add all DM controls (remove button, editable inputs for rotate, sight, light, hp, init, ac)
						menuHTML += `
							<button class="remove-token" style="width: 100%; background: #ffdddd; border: 1px solid red; padding: 6px; cursor: pointer;">Remove Token</button>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Rotate:</label>
								<input type="number" class="rotate-input" value="${token.rotation || 0}" min="0" max="360" step="1" style="flex-grow: 1; padding: 4px;">
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Sight:</label>
								<input type="number" class="sight-input" value="${token.sightRadius || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Is Light Source:</label>
                                <input type="checkbox" id="context-isLightSource" class="light-source-checkbox" ${token.isLightSource ? 'checked' : ''} style="flex-grow: 1;">
                            </div>
                            <div class="light-range-inputs" style="display: ${token.isLightSource ? 'flex' : 'none'}; flex-direction: column; gap: 6px; padding-left: 10px; border-left: 1px solid #ccc;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                     <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Bright:</label>
                                     <input type="number" id="context-bright-range" class="bright-range-input" value="${token.brightRange || 0}" min="0" style="flex-grow: 1; padding: 4px;">
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                     <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Dim:</label>
                                     <input type="number" id="context-dim-range" class="dim-range-input" value="${token.dimRange || 0}" min="0" style="flex-grow: 1; padding: 4px;">
                                </div>
                            </div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Max HP:</label>
								<input type="number" class="max-hp-input" value="${token.maxHP || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Cur HP:</label>
								<input type="number" class="hp-input" value="${token.hp || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
								<input type="number" class="init-input" value="${token.initiative || 0}" style="flex-grow: 1; padding: 4px;">
							</div>
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">AC:</label>
								<input type="number" class="ac-input" value="${token.ac || 0}" min="0" style="flex-grow: 1; padding: 4px;">
							</div>
						`;

					} else if (token.owner === username || (token.isMinion && token.parentOwner === username)) {
						// Player owns token - Add player-editable fields (Rotate) and viewable (Sight, Light, HP, Init, AC)
						menuHTML += `
							<div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Rotate:</label>
								<input type="number" class="rotate-input" value="${token.rotation || 0}" min="0" max="360" step="1" style="flex-grow: 1; padding: 4px;">
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Sight:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.sightRadius || 0}</div>
							</div>
                            <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Light:</label>
                                 <div style="flex-grow: 1; font-size: 0.9em;">${token.isLightSource ? `${token.brightRange || 0}/${token.dimRange || 0}` : 'No'}</div>
							</div>
                            <!-- Add read-only HP, Init, and AC displays for player-owned tokens -->
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">HP:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.maxHP > 0 && token.hp !== undefined ? `${token.hp}/${token.maxHP}` : (token.hp !== undefined ? token.hp : '--/--')}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.initiative !== undefined ? token.initiative : '--'}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">AC:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.ac !== undefined ? token.ac : '--'}</div>
                             </div>
                             <!-- Optional: Add player-editable HP/Init here if desired. Uncomment and update Save logic below. -->
                             <!--
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Cur HP:</label>
                                <input type="number" class="hp-input" value="${token.hp || 0}" min="0" style="flex-grow: 1; padding: 4px;">
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
                                <input type="number" class="init-input" value="${token.initiative || 0}" style="flex-grow: 1; padding: 4px;">
                            </div>
                            -->
						`;

					} else {
                        // Player does not own token - Add name and read-only info (Light, maybe HP/Init/AC)
                        // For non-owned tokens, let's add read-only HP, Init, and AC too, as they are combat relevant
                         menuHTML += `
                            <div style="font-size: 0.9em; padding: 6px; text-align: center;">(You don't own this token)</div>
                             <div style="display: flex; align-items: center; gap: 6px;">
								<label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Light:</label>
                                 <div style="flex-grow: 1; font-size: 0.9em;">${token.isLightSource ? `${token.brightRange || 0}/${token.dimRange || 0}` : 'No'}</div>
							</div>
                            <!-- Add read-only displays for HP/Init/AC for non-owned tokens -->
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">HP:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.maxHP > 0 && token.hp !== undefined ? `${token.hp}/${token.maxHP}` : (token.hp !== undefined ? token.hp : '--/--')}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">Init:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.initiative !== undefined ? token.initiative : '--'}</div>
                             </div>
                             <div style="display: flex; align-items: center; gap: 6px;">
                                <label style="font-size: 0.9em; flex-shrink: 0; width: 60px;">AC:</label>
                                <div style="flex-grow: 1; font-size: 0.9em;">${token.ac !== undefined ? token.ac : '--'}</div>
                             </div>
                        `;
                    }

                    // --- Now add the buttons using correct JavaScript conditionals ---
                    // This block correctly appends the appropriate buttons AFTER the content HTML
                    if (currentRole === 'dm' || token.owner === username || (token.isMinion && token.parentOwner === username)) {
                         // If user is DM OR owns the token (or its minion), add Save and Cancel buttons
                         menuHTML += `
                            <div style="display: flex; gap: 6px; margin-top: 4px;">
                                <button class="save-button" style="flex-grow: 1; background: #ddffdd; border: 1px solid green; padding: 6px; cursor: pointer;">Save</button>
                                <button class="cancel-button" style="flex-grow: 1; background: #dddddd; border: 1px solid gray; padding: 6px; cursor: pointer;">Cancel</button>
                            </div>
                         `;
                    } else {
                         // Otherwise (user is a player and *doesn't* own the token), add only the Close button
                         menuHTML += `<button class="cancel-button" style="width: 100%; background: #dddddd; border: 1px solid gray; padding: 6px; cursor: pointer; margin-top: 4px;">Close</button>`;
                    }


					menu.innerHTML = menuHTML; // Assign the final built HTML string to the menu element
					document.body.appendChild(menu); // Append the menu to the document


					// --- Attach Event Listeners (MUST query elements *after* innerHTML is set) ---

					// Positioning logic (Your original positioning logic seems correct)
					const menuWidthActual = menu.offsetWidth;
					const menuHeightActual = menu.offsetHeight;
                    menuX = clientX;
					menuY = clientY;
                    if (menuX + menuWidthActual > window.innerWidth - 10) { menuX = window.innerWidth - menuWidthActual - 10; }
                    if (menuY + menuHeightActual > window.innerHeight - 10) { menuY = window.innerHeight - menuHeightActual - 10; }
                    menuX = Math.max(10, menuX); // Ensure min 10px from left/top
                    menuY = Math.max(10, menuY);
					menu.style.left = `${menuX}px`;
					menu.style.top = `${menuY}px`;


                    // Add listener for Light Source checkbox to show/hide range inputs (DM only)
                    // Query using the ID added to the input in the DM menuHTML
					const lightSourceCheckbox = menu.querySelector('#context-isLightSource'); // Use ID
					// Also query the bright/dim inputs here for the change listener
					const brightRangeInputForListener = menu.querySelector('#context-bright-range');
					const dimRangeInputForListener = menu.querySelector('#context-dim-range');

					// The lightRangeInputsDiv itself is queried by class as it's the container div
					const lightRangeInputsDiv = menu.querySelector('.light-range-inputs');

					// This check implicitly only runs for DM menus because only DM menus have the checkbox/div
					if (lightSourceCheckbox && lightRangeInputsDiv && brightRangeInputForListener && dimRangeInputForListener) {
						lightSourceCheckbox.addEventListener('change', () => {
							const isChecked = lightSourceCheckbox.checked;
							lightRangeInputsDiv.style.display = isChecked ? 'flex' : 'none';
							// Optional: Clear values when unchecked
							if (!isChecked) {
								brightRangeInputForListener.value = '0';
								dimRangeInputForListener.value = '0';
							}
						});
						// No need to set initial state here, it's set in the menuHTML string based on token data
					}


                    // Listener for the Remove button (DM only)
					const removeButton = menu.querySelector('.remove-token');
					if (removeButton) { // This implicitly checks for DM role
						removeButton.addEventListener('click', (e) => {
                            e.stopPropagation();
							socket.emit('removeToken', token.id);
							menu.remove();
							isContextMenuOpen = false;
						});
					}

                    // Listener for the Save button (DM or Player Owner)
					const saveButton = menu.querySelector('.save-button');
					if (saveButton) { // This implicitly checks for DM or Player Owner existence because those are the only roles with this button
						saveButton.addEventListener('click', (e) => {
							e.stopPropagation();

							const rotateInput = menu.querySelector('.rotate-input');
							let rotation = rotateInput ? parseInt(rotateInput.value, 10) % 360 : token.rotation;
							if (isNaN(rotation)) rotation = token.rotation || 0;

							// Start building the update object - always include tokenId and rotation
							let statsToUpdate = { tokenId: token.id, rotation: rotation };

                            // Query all possible inputs that could exist in the menu, regardless of role.
                            // Their values will only be used if the role allows it and the input element exists.
                            const maxHPInput = menu.querySelector('.max-hp-input');       // DM only
                            const hpInput = menu.querySelector('.hp-input');             // DM (or Player if uncommented)
                            const initInput = menu.querySelector('.init-input');           // DM (or Player if uncommented)
                            const acInput = menu.querySelector('.ac-input');             // DM only
                            const sightInput = menu.querySelector('.sight-input');         // DM only
                            const lightSourceCheckboxForSave = menu.querySelector('#context-isLightSource'); // DM only (Use the ID)
                            const brightRangeInputForSave = menu.querySelector('#context-bright-range');     // DM only (Use the ID)
                            const dimRangeInputForSave = menu.querySelector('#context-dim-range');         // DM only (Use the ID)


							// Add editable field values to statsToUpdate if they exist in the menu HTML for this role
							// These checks implicitly handle which fields were available to the user
							if (maxHPInput) statsToUpdate.maxHP = parseInt(maxHPInput.value, 10) || token.maxHP; // Use existing token stat as fallback if input is missing or parsing fails
							if (hpInput) statsToUpdate.hp = parseInt(hpInput.value, 10) || token.hp;
							if (initInput) statsToUpdate.initiative = parseInt(initInput.value, 10) || token.initiative;
							if (acInput) statsToUpdate.ac = parseInt(acInput.value, 10) || token.ac;
                            if (sightInput) statsToUpdate.sightRadius = parseInt(sightInput.value, 10) || token.sightRadius;
                            // Use the correctly queried lightSourceCheckbox variable
                            if (lightSourceCheckboxForSave) statsToUpdate.isLightSource = lightSourceCheckboxForSave.checked;
                            if (brightRangeInputForSave) statsToUpdate.brightRange = parseInt(brightRangeInputForSave.value, 10) || token.brightRange;
                            if (dimRangeInputForSave) statsToUpdate.dimRange = parseInt(dimRangeInputForSave.value, 10) || token.dimRange;


                            // Ensure dim is always >= bright before sending (Server does this too, but belt-and-suspenders)
                            // Use default 0 if brightRange/dimRange are not defined yet
                            const finalBright = statsToUpdate.brightRange !== undefined ? statsToUpdate.brightRange : (token.brightRange || 0);
                            const finalDim = statsToUpdate.dimRange !== undefined ? statsToUpdate.dimRange : (token.dimRange || 0);
                            statsToUpdate.dimRange = Math.max(finalBright, finalDim);
                            statsToUpdate.brightRange = finalBright; // Ensure brightRange is also explicitly sent


                            // Emit the update - Server will handle permissions based on role and ownership
                            // The statsToUpdate object now contains all fields that *could* have been edited.
                            // Server side should only apply fields permitted for the user's role/ownership.
							socket.emit('updateTokenStats', statsToUpdate);

							menu.remove();
							isContextMenuOpen = false;
						});
					}

                    // Listener for the Cancel/Close button (All roles)
					const cancelButton = menu.querySelector('.cancel-button');
					if (cancelButton) { // This button always exists
						cancelButton.addEventListener('click', (e) => {
							e.stopPropagation();
							menu.remove();
							isContextMenuOpen = false;
						});
					}

					// Prevent clicks/touches inside the menu from closing it immediately via document listeners
					menu.addEventListener('click', (e) => e.stopPropagation());
                    menu.addEventListener('touchstart', (e) => e.stopPropagation());


					// Add listeners to close menu when clicking/touching outside
					// These need to be added to the document, but *after* the menu exists
					function closeMenu(event) {
						// Check if the event target is outside the menu.
						if (isContextMenuOpen && menu && !menu.contains(event.target)) {
							menu.remove();
							isContextMenuOpen = false;
							// Remove these specific listeners after closing
							document.removeEventListener('click', closeMenu);
							document.removeEventListener('touchstart', closeMenu);
                            document.removeEventListener('contextmenu', closeMenu);
						}
					}

                    // Use requestAnimationFrame to delay adding the listeners slightly
                    // This prevents the current click/touch that opened the menu from immediately closing it
					requestAnimationFrame(() => {
						document.addEventListener('click', closeMenu);
						document.addEventListener('touchstart', closeMenu);
                        document.addEventListener('contextmenu', closeMenu); // Also close on right-click outside
					});

                    // Set the flag to true after the menu is fully shown and listeners are attached
                    // isContextMenuOpen is set to true at the very start of the function now. No need to set it here again.
				} // End showContextMenu

				function handleLongPress(clientX, clientY) {
					if (isLoading || currentInteractionMode !== 'interact' || isContextMenuOpen) return;

					const rect = canvas.getBoundingClientRect();
					const canvasX = (clientX - rect.left - panX) / scale;
					const canvasY = (clientY - rect.top - panY) / scale;

					const tokenInfo = getTokenAtPosition(canvasX, canvasY);
					// Show context menu if a token is hit, regardless of ownership (limited options for others)
					if (tokenInfo) {
						showContextMenu(clientX, clientY, tokenInfo.index);
					}
				}

				function resetInteraction() {
					// If wall drawing was in progress, emit the changes
					if (isDrawing && Object.keys(pendingWallChanges).length > 0) {
						socket.emit('updateWalls', walls);
						pendingWallChanges = {}; // Clear pending changes after emitting
					}
					// Reset interaction states
					draggedToken = null;
					draggedTokenIndex = -1;
					isPanning = false;
					isDrawing = false; // For walls
					isLongPressing = false;
					// Clear any pending long press timer
					if (longPressTimeout) {
						clearTimeout(longPressTimeout);
						longPressTimeout = null;
					}
					// Flag mask as dirty because token movement or ending wall drawing might change visibility
                    maskDirty = true;
					drawGrid(); // Redraw to reflect final state and clear effects (like drag)
				}

				// --- Add Token Form Submission ---
				addTokenForm.addEventListener('submit', (event) => {
					event.preventDefault();
					event.stopPropagation();

					// Get form values
					const nameValue = document.getElementById('token-name').value.trim();
					const imageValue = document.getElementById('token-image').value.trim();
					const imageFile = document.getElementById('token-image-file').files[0];
					const colorValue = document.getElementById('token-color').value.trim();
					const sizeValue = parseInt(document.getElementById('token-size').value, 10);
					const rotationValue = parseInt(document.getElementById('token-rotation').value, 10) % 360;
					// DM-only fields - check if element exists before accessing value
					const maxHPInput = document.getElementById('token-max-hp');
					const hpInput = document.getElementById('token-hp');
					const initInput = document.getElementById('token-init');
					const acInput = document.getElementById('token-ac');
                    const sightRadiusInput = document.getElementById('token-sight-radius');
                    const isLightSourceCheckbox = document.getElementById('isLightSource');
                    const brightRangeInput = document.getElementById('token-bright-range');
                    const dimRangeInput = document.getElementById('token-dim-range');


					const maxHPValue = currentRole === 'dm' && maxHPInput ? (parseInt(maxHPInput.value, 10) || 0) : 0;
					const hpValue = currentRole === 'dm' && hpInput ? (parseInt(hpInput.value, 10) || 0) : 0;
					const initValue = initInput ? (parseInt(initInput.value, 10) || 0) : 0; // Init can be set by players too? Current form says DM-only class, so treat as DM-only for submission
					const acValue = acInput ? (parseInt(acInput.value, 10) || 0) : 0;     // AC can be set by players too? Current form says DM-only class, so treat as DM-only for submission
					const sightRadiusValue = currentRole === 'dm' && sightRadiusInput ? (parseInt(sightRadiusInput.value, 10) || 0) : 0; // Sight is DM-only
                    const isLightSource = currentRole === 'dm' && isLightSourceCheckbox ? isLightSourceCheckbox.checked : false; // Light is DM-only
                    const brightRangeValue = currentRole === 'dm' && isLightSource && brightRangeInput ? (parseInt(brightRangeInput.value, 10) || 0) : 0; // Bright is DM-only
                    const dimRangeValue = currentRole === 'dm' && isLightSource && dimRangeInput ? (parseInt(dimRangeInput.value, 10) || 0) : 0; // Dim is DM-only


					const isMinion = document.getElementById('isMinion').checked;

					function submitToken(imageUrl) {
						if (!imageUrl && !colorValue) {
							showNotification('Please provide either an image (URL or file) or a color for the token.', true);
							return;
						}

						const newTokenData = {
							name: nameValue || 'Unnamed Token', // Default name
							x: Math.floor(currentGridWidthCells / 2), // Default position
							y: Math.floor(currentGridHeightCells / 2),
							imageUrl: imageUrl || null,
							imageFilename: imageFile ? imageFile.name : null,
							backgroundColor: !imageUrl ? (colorValue || 'grey') : null,
							size: sizeValue || 1, // Default size
							rotation: rotationValue || 0, // Default rotation

							// Include DM-only stats (will be validated/ignored by server if role is not DM)
							maxHP: maxHPValue,
							hp: hpValue,
							initiative: initValue, // Send initiative/AC even if DM-only class, server will handle role check
							ac: acValue,
                            sightRadius: sightRadiusValue,
                            isLightSource: isLightSource,
                            brightRange: brightRangeValue,
                            dimRange: dimRangeValue,

							isMinion: isMinion,
							owner: username // Set owner based on logged-in user
							// parentOwner set on server if isMinion is true
						};

						console.log(`Attempting to add token: ${newTokenData.name}`);

						try {
							socket.emit('addToken', newTokenData);
						} catch (err) {
							console.error('Error emitting addToken:', err);
							showNotification('Failed to add token. Please try again.', true);
						}

						// Clear the form after submission
						document.getElementById('token-name').value = '';
						document.getElementById('token-image').value = '';
						document.getElementById('token-image-file').value = '';
						document.getElementById('token-color').value = '';
						document.getElementById('token-size').value = '1';
						document.getElementById('token-rotation').value = '0';
                        // Clear DM-only fields only if they exist (DM view)
						if (maxHPInput) maxHPInput.value = '0';
						if (hpInput) hpInput.value = '0';
						if (initInput) initInput.value = '0';
						if (acInput) acInput.value = '0';
                        if (sightRadiusInput) sightRadiusInput.value = '30'; // Reset sight radius default
                        if (isLightSourceCheckbox) isLightSourceCheckbox.checked = false; // Reset light source toggle
                        // Hide light range inputs and reset their values if they exist
                        const lightRangeInputsDiv = document.querySelector('#add-token-form .light-range-inputs');
                         if (lightRangeInputsDiv) lightRangeInputsDiv.style.display = 'none';
                         if (brightRangeInput) document.getElementById('token-bright-range').value = '0';
                         if (dimRangeInput) document.getElementById('token-dim-range').value = '0';


						document.getElementById('isMinion').checked = false;
					}

					if (imageFile) {
						imageToDataUrl(imageFile, (dataUrl) => {
							submitToken(dataUrl);
						});
					} else {
						submitToken(imageValue);
					}
				});

                // Add listener for Light Source checkbox in the DM Add Token form
                const addTokenLightSourceCheckbox = document.getElementById('isLightSource');
                const addTokenLightRangeInputsDiv = document.querySelector('#add-token-form .light-range-inputs');
                if (addTokenLightSourceCheckbox && addTokenLightRangeInputsDiv) {
                    addTokenLightSourceCheckbox.addEventListener('change', () => {
                        addTokenLightRangeInputsDiv.style.display = addTokenLightSourceCheckbox.checked ? 'flex' : 'none';
                    });
                     // Set initial display based on default checkbox state
                     addTokenLightRangeInputsDiv.style.display = addTokenLightSourceCheckbox.checked ? 'flex' : 'none';
                }


				// --- Player Token Form Submission ---
				playerTokenForm.addEventListener('submit', (event) => {
					event.preventDefault();
					event.stopPropagation();

					// Get form values
					const nameValue = document.getElementById('player-token-name').value.trim();
					const imageValue = document.getElementById('player-token-image').value.trim();
					const imageFile = document.getElementById('player-token-image-file').files[0];
					const colorValue = document.getElementById('player-token-color').value.trim();
					const sizeValue = parseInt(document.getElementById('player-token-size').value, 10);
					const rotationValue = parseInt(document.getElementById('player-token-rotation').value, 10) % 360;
					const isMinion = document.getElementById('playerIsMinion').checked;

					// Player tokens have default/no values for DM-only stats/light when added
					const playerDefaultSightRadius = 30; // Define default sight radius for player tokens

					function submitPlayerToken(imageUrl) {
						if (!imageUrl && !colorValue) {
							showNotification('Please provide either an image (URL or file) or a color for the token.', true);
							return;
						}

						const newTokenData = {
							// ID is generated on the server
							name: nameValue || `${username || 'Player'}'s Token`, // Default name
							x: Math.floor(currentGridWidthCells / 2), // Default position
							y: Math.floor(currentGridHeightCells / 2),
							imageUrl: imageUrl || null,
							imageFilename: imageFile ? imageFile.name : null,
							backgroundColor: !imageUrl ? (colorValue || 'grey') : null,
							size: sizeValue || 1, // Default size
							rotation: rotationValue || 0, // Default rotation

							// DM-only fields default to 0 or false for player-added tokens
							maxHP: 0,
							hp: 0,
							initiative: 0,
							ac: 0,
                            sightRadius: playerDefaultSightRadius, // Assign default sight radius
                            isLightSource: false, // Players cannot add light sources
                            brightRange: 0,
                            dimRange: 0,

							isMinion: isMinion, // Player can mark their own as minions?
							owner: username // Set owner based on logged-in user
							// parentOwner set on server if isMinion is true
						};

						console.log(`Attempting to add player token: ${newTokenData.name}`);

						try {
							socket.emit('addToken', newTokenData);
						} catch (err) {
							console.error('Error emitting addToken:', err);
							showNotification('Failed to add token. Please try again.', true);
						}

						// Clear the form after submission
						document.getElementById('player-token-name').value = '';
						document.getElementById('player-token-image').value = '';
						document.getElementById('player-token-image-file').value = '';
						document.getElementById('player-token-color').value = '';
						document.getElementById('player-token-size').value = '1';
						document.getElementById('player-token-rotation').value = '0';
						document.getElementById('playerIsMinion').checked = false;
					}

					if (imageFile) {
						imageToDataUrl(imageFile, (dataUrl) => {
							submitPlayerToken(dataUrl);
						});
					} else {
						submitPlayerToken(imageValue);
					}
				});


				darkModeToggle.addEventListener('click', () => {
					const isDarkMode = !document.body.classList.contains('dark-mode');
					document.body.classList.toggle('dark-mode', isDarkMode);
					darkModeToggle.textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
					localStorage.setItem('darkMode', isDarkMode);
					updateDarkModeStyles(isDarkMode);
					drawGrid();
				});

				showControlsButton.addEventListener('click', () => {
					controlsWrapper.style.display = 'block';
					showControlsButton.style.display = 'none';
				});

				closeControlsButton.addEventListener('click', () => {
					controlsWrapper.style.display = 'none';
					showControlsButton.style.display = 'block';
				});

				gridSizeSelect.addEventListener('change', () => {
					const sizeKey = gridSizeSelect.value;

					// *** Player Role Check (moved earlier for clarity) ***
					if (currentRole !== 'dm') {
						showNotification("Only the DM can change the scene size.", false);
						// Revert the select value visually if player tried to change it
						// Find the current size key based on actual grid dimensions
						const currentSizeKey = Object.keys(gridSizeOptions).find(
							key => gridSizeOptions[key]?.width === currentGridWidthCells &&
								   gridSizeOptions[key]?.height === currentGridHeightCells
						); // Note: If current size IS custom, this might be undefined.

						// If the player selected 'custom', or if the current size *is* custom, ensure the select reflects reality
						if (sizeKey === 'custom' || !currentSizeKey) {
							 // If current size isn't a preset, or they tried to select custom, leave it as custom
							 gridSizeSelect.value = 'custom';
							 // Ensure custom inputs are shown and populated if the current size *is* custom
							 if (customSizeInputsDiv && customWidthInput && customHeightInput) {
								 customWidthInput.value = currentGridWidthCells;
								 customHeightInput.value = currentGridHeightCells;
								 customSizeInputsDiv.style.display = 'block';
							 }
						} else {
							// If current size is a preset, revert to that preset
							 gridSizeSelect.value = currentSizeKey;
							 // Ensure custom inputs are hidden if reverting to a preset
							 if (customSizeInputsDiv) {
								 customSizeInputsDiv.style.display = 'none';
							 }
						}
						return; // Stop processing for players
					}

					// *** DM Logic ***
					if (sizeKey === 'custom') {
						// DM selected 'Custom' from the dropdown
						customWidthInput.value = currentGridWidthCells; // Pre-fill with current size
						customHeightInput.value = currentGridHeightCells;
						customSizeInputsDiv.style.display = 'block'; // Show the custom input fields
						// We don't emit here; the DM needs to click "Apply Custom Size"
					} else {
						// DM selected a PRESET size from the dropdown
						customSizeInputsDiv.style.display = 'none'; // Hide the custom input fields

						// Look up the dimensions for the selected preset
						const newGridSize = gridSizeOptions[sizeKey];

						if (!newGridSize) {
							 // This check catches cases where the selected value *isn't* 'custom' but also *isn't* a valid preset key
							 // (e.g., if someone modified the HTML options incorrectly)
							 console.error("Error: Selected preset size key not found in options:", sizeKey);
							 showNotification("Error: Invalid preset size selected.", true);

							 // Revert select to the *actual* current size (which might be a different preset or custom)
							 const currentSizeKey = Object.keys(gridSizeOptions).find(
								 key => gridSizeOptions[key]?.width === currentGridWidthCells &&
										gridSizeOptions[key]?.height === currentGridHeightCells
				);

							 if (currentSizeKey) {
								 gridSizeSelect.value = currentSizeKey;
								 customSizeInputsDiv.style.display = 'none';
							 } else {
								 gridSizeSelect.value = 'custom'; // It must be a custom size already
								 if (customSizeInputsDiv && customWidthInput && customHeightInput) {
									 customWidthInput.value = currentGridWidthCells;
									 customHeightInput.value = currentGridHeightCells;
									 customSizeInputsDiv.style.display = 'block';
								 }
							 }
							 return;
						}

						// Emit the valid preset size to the server
						socket.emit('updateGridSize', { width: newGridSize.width, height: newGridSize.height });
						showNotification(`Updating grid size to ${sizeKey} (${newGridSize.width}x${newGridSize.height})...`);
					}
				});
				
				applyCustomSizeButton.addEventListener('click', () => {
					if (currentRole !== 'dm') {
						showNotification("Only the DM can apply custom scene sizes.", false);
						return;
					}

					const widthValue = customWidthInput.value;
					const heightValue = customHeightInput.value;

					const customWidth = parseInt(widthValue, 10);
					const customHeight = parseInt(heightValue, 10);

					// Basic validation (matches input attributes)
					const minSize = 5;
					const maxSize = 500; // Match your input max attribute

					if (isNaN(customWidth) || isNaN(customHeight) ||
						customWidth < minSize || customWidth > maxSize ||
						customHeight < minSize || customHeight > maxSize) {
						showNotification(`Invalid custom size. Width and Height must be numbers between ${minSize} and ${maxSize}.`, true);
						return;
					}

					// Send the custom grid size update to the server
					socket.emit('updateGridSize', { width: customWidth, height: customHeight });
					showNotification(`Updating grid size to custom dimensions (${customWidth}x${customHeight})...`);

					// Optional: Hide the custom inputs again after applying
					// customSizeInputsDiv.style.display = 'none';
				});


				// --- Interaction Mode Buttons ---
				function setInteractionMode(mode) {
					currentInteractionMode = mode;
					// Reset button styles
					interactButton.style.backgroundColor = '';
					drawWallButton.style.backgroundColor = '';
					eraseWallButton.style.backgroundColor = '';

					// Set active button style
					if (mode === 'interact') {
						interactButton.style.backgroundColor = '#5bc0de';
					} else if (mode === 'draw') {
						drawWallButton.style.backgroundColor = '#5bc0de';
					} else if (mode === 'erase') {
						eraseWallButton.style.backgroundColor = '#5bc0de';
					}
                    // No need to drawGrid immediately, will happen on next mouse/touch event
				}

				interactButton.addEventListener('click', () => setInteractionMode('interact'));
				drawWallButton.addEventListener('click', () => {
                    if (currentRole !== 'dm') {
                         showNotification("Only the DM can draw walls.", false);
                         return;
                    }
                    setInteractionMode('draw');
                });
				eraseWallButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can erase walls.", false);
                         return;
                    }
                    setInteractionMode('erase');
                });

                // Set initial mode style
                setInteractionMode(currentInteractionMode);


				toggleGridButton.addEventListener('click', () => {
					if (currentRole === 'dm') {
						socket.emit('updateGridVisibility', !isGridVisible);
					} else {
                         showNotification("Only the DM can toggle the grid lines.", false);
                    }
				});
				
				if (toggleAllVisibleButton) { // Ensure the button element was found
                     console.log("Attaching click listener to toggleAllVisibleButton."); // DEBUG LOG: Is listener being attached?
                     toggleAllVisibleButton.addEventListener('click', () => {
                         console.log("Toggle All Visible button click event fired!"); // DEBUG LOG 1
                         console.log("Current role inside listener:", currentRole); // DEBUG LOG 2

                         // Only allow the DM to click this button
                         if (currentRole === 'dm') {
                             console.log("User is DM. Proceeding with toggle logic."); // DEBUG LOG 3
                             const newState = !isMapFullyVisible;
                             console.log("Emitting 'toggleMapVisibility' with newState:", newState); // DEBUG LOG 4

                             // Emit the toggle state to the server
                             socket.emit('toggleMapVisibility', newState);
                             // Provide immediate feedback to the DM client (this will be updated again by the server broadcast)
                             showNotification(isMapFullyVisible ? 'Turning off "All Visible" map.' : 'Turning on "All Visible" map.');
                             // The server will broadcast the official state back, which updates the local state and button text
                         } else {
                              console.log("User is not DM. Blocking toggle."); // DEBUG LOG 5
                              showNotification("Only the DM can toggle the 'All Visible' map feature.", false);
                         }
                     });
                } else {
                    console.warn("toggleAllVisibleButton element not found. Event listener not attached."); // DEBUG LOG: Button not found
                }
				
				resetViewButton.addEventListener('click', () => {
					scale = 1;
					// Center the grid in the canvas
					panX = (canvas.width - currentGridWidthCells * gridSize * scale) / 2;
					panY = (canvas.height - currentGridHeightCells * gridSize * scale) / 2;
					drawGrid();
				});

				backgroundForm.addEventListener('submit', (event) => event.preventDefault()); // Prevent default form submit

				loadBackgroundButton.addEventListener('click', () => {
					if (currentRole !== 'dm') {
                         showNotification("Only the DM can change the background.", false);
                         return;
                    }
					const url = backgroundImageUrlInput.value.trim();
					if (url) {
						socket.emit('updateBackground', url);
                        showNotification('Sending background URL to server...');
					} else {
                         showNotification("Please enter a background image URL.", false);
                    }
				});

				clearBackgroundButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can clear the background.", false);
                         return;
                    }
					socket.emit('updateBackground', '');
                    showNotification('Clearing background...');
				});

				backgroundImageFileInput.addEventListener('change', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can upload a background.", false);
                         return;
                    }
					const file = backgroundImageFileInput.files[0];
					if (file) {
						imageToDataUrl(file, (dataUrl) => {
							if (dataUrl) {
								socket.emit('updateBackground', dataUrl);
                                showNotification('Uploading background image...');
							} else {
                                showNotification("Failed to read background image file.", true);
                            }
						});
                        backgroundImageFileInput.value = ''; // Clear file input
					}
				});

				saveStateButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can save the state.", false);
                         return;
                    }
					socket.emit('saveState');
					// Notification handled by server 'saveSuccess' event
				});

				downloadStateButton.addEventListener('click', () => {
                     if (currentRole !== 'dm') {
                         showNotification("Only the DM can download the state.", false);
                         return;
                    }
					const state = {
						tokens: tokensData.map(token => ({ // Strip imageObj for download
                            id: token.id,
                            name: token.name,
                            x: token.x,
                            y: token.y,
                            imageUrl: token.imageUrl,
                            imageFilename: token.imageFilename,
                            backgroundColor: token.backgroundColor,
                            size: token.size,
                            rotation: token.rotation,
                            maxHP: token.maxHP,
                            hp: token.hp,
                            initiative: token.initiative,
                            ac: token.ac,
                            sightRadius: token.sightRadius, // Include sight radius
                            isLightSource: token.isLightSource, // Include light source properties
                            brightRange: token.brightRange,
                            dimRange: token.dimRange,
                            isMinion: token.isMinion,
                            owner: token.owner,
                            parentOwner: token.parentOwner
                        })),
						walls: normalizeWalls(walls, currentGridWidthCells, currentGridHeightCells),
						isGridVisible: isGridVisible, // Include grid visibility
                        isMapFullyVisible: isMapFullyVisible, // NEW: Include map visibility toggle state
						backgroundImageUrl,
						gridSize: { width: currentGridWidthCells, height: currentGridHeightCells },
                        // Optionally save current view state (pan/scale) - Note: This isn't currently loaded by server/client
                        // viewState: { scale, panX, panY } // Let's remove this from the download state for now to keep it simple
					};
					const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = 'thorgrid-state.json'; // Use app name
					a.click();
					URL.revokeObjectURL(url);
					showNotification('State downloaded.');
				});

				importStateButton.addEventListener('click', () => {
                    if (currentRole !== 'dm') {
                         showNotification("Only the DM can import the state.", false);
                         return;
                    }
					importStateFile.click();
				});

				importStateFile.addEventListener('change', () => {
					const file = importStateFile.files[0];
					if (file) {
						const reader = new FileReader();
						reader.onload = (e) => {
							try {
								const state = JSON.parse(e.target.result);
                                // Basic validation before emitting to server
                                if (state && Array.isArray(state.tokens) && Array.isArray(state.walls) && state.gridSize) {
                                    socket.emit('importState', state); // Server handles processing and broadcasting fullStateUpdate
                                    showNotification('Importing state...');
                                    // Notification handled by server 'saveSuccess' event after successful import
                                } else {
                                     showNotification('Invalid state file format.', true);
                                }
							} catch (err) {
								console.error('Failed to parse imported state:', err);
								showNotification('Failed to import state. Invalid JSON.', true);
							}
						};
						reader.onerror = () => {
							console.error('Failed to read file:', file.name);
							showNotification('Failed to read file.', true);
						};
						reader.readAsText(file);
						importStateFile.value = ''; // Clear file input
					}
				});

				canvas.addEventListener('mousedown', (event) => {
                    // Only process if not loading and not in context menu
                    if (isLoading || isContextMenuOpen) return;

					if (event.button === 0) { // Left click
						handleInteractionStart(event.clientX, event.clientY);
					}
				});

				canvas.addEventListener('contextmenu', (event) => {
					event.preventDefault();
					if (isLoading || currentInteractionMode !== 'interact' || isContextMenuOpen) return;

					const rect = canvas.getBoundingClientRect();
					const canvasX = (event.clientX - rect.left - panX) / scale;
					const canvasY = (event.clientY - rect.top - panY) / scale;

					const tokenInfo = getTokenAtPosition(canvasX, canvasY);
					// Show context menu if a token is hit, regardless of ownership (limited options for others)
					if (tokenInfo) {
						showContextMenu(event.clientX, event.clientY, tokenInfo.index);
					}
				});

				canvas.addEventListener('mousemove', (event) => {
					const rect = canvas.getBoundingClientRect();
					const canvasX = (event.clientX - rect.left - panX) / scale;
					const canvasY = (event.clientY - rect.top - panY) / scale;

					// --- Handle token dragging ---
					if (draggedToken) {
						const tokenSize = draggedToken.size || 1;
						// Calculate the potential new grid position based on mouse position and initial offset
						const newX = Math.floor((canvasX - offsetX) / gridSize);
						const newY = Math.floor((canvasY - offsetY) / gridSize);
						const maxX = currentGridWidthCells - tokenSize;
						const maxY = currentGridHeightCells - tokenSize;

						// Clamp the *intended* final position to grid bounds FIRST
						const clampedX = Math.max(0, Math.min(newX, maxX));
						const clampedY = Math.max(0, Math.min(newY, maxY));

                        // --- Implement Single-Step Collision Check ---
                        // Only perform this logic if the intended clamped position is DIFFERENT from the token's current cell
                        if (draggedToken.x !== clampedX || draggedToken.y !== clampedY) {

                            const currentX = draggedToken.x;
                            const currentY = draggedToken.y;

                            // Calculate the proposed next step: move one cell towards the clamped destination
                            // Math.sign gives -1, 0, or 1
                            let targetX = currentX + Math.sign(clampedX - currentX);
                            let targetY = currentY + Math.sign(clampedY - currentY);

                            // Re-clamp this single step to ensure it's still within bounds (should be, but safe)
                            targetX = Math.max(0, Math.min(targetX, maxX));
                            targetY = Math.max(0, Math.min(targetY, maxY));

                            // Now check for collision at this *single step* target cell
                            if (!isCollision(targetX, targetY, draggedToken, walls, currentGridWidthCells, currentGridHeightCells)) {
                                // If there is NO collision at the single step target:
                                // Update the token's local position to this new single step cell
                                draggedToken.x = targetX;
                                draggedToken.y = targetY;
                                // console.log(`Mouse moving token ${draggedToken.name} to x: ${draggedToken.x}, y: ${draggedToken.y}`); // COMMENTED OUT
                                // Emit the updated position to the server (the server will also validate)
                                socket.emit('moveToken', {
                                    tokenId: draggedToken.id,
                                    x: draggedToken.x,
                                    y: draggedToken.y,
                                    rotation: draggedToken.rotation
                                });
                                maskDirty = true; // Token moved, need to recalculate mask (for FoW)
                                drawGrid(); // Redraw immediately for smooth drag feedback
                            } else {
                                // If there IS a collision at the single step target:
                                // The token's position is NOT updated. It stays in its last valid cell.
                                // This prevents moving into the wall, even if the mouse jumps over it.
                                console.log(`Collision detected for ${draggedToken.name} at [${targetX}, ${targetY}]. Blocking move.`);
                                // Optional: Add visual feedback here (e.g., temporary red tint)
                            }
                        }
                        // If the intended clamped position is the same as current, do nothing (token didn't move cells).

					// --- Handle panning ---
					} else if (isPanning) { // Handle panning if no token is dragged
						panX += event.clientX - startX;
						panY += event.clientY - startY;
						startX = event.clientX;
						startY = event.clientY;
						drawGrid();

					// --- Handle wall drawing/erasing ---
					} else if (isDrawing && currentRole === 'dm' && (currentInteractionMode === 'draw' || currentInteractionMode === 'erase')) { // Only draw/erase if in correct mode and DM
						const gridX = Math.floor(canvasX / gridSize);
						const gridY = Math.floor(canvasY / gridSize);
						// Check if the mouse is within grid bounds
						if (gridX >= 0 && gridX < currentGridWidthCells && gridY >= 0 && gridY < currentGridHeightCells) {
							// Ensure wall array is initialized for the row if it doesn't exist
							if (!walls[gridY]) walls[gridY] = Array(currentGridWidthCells).fill(0);
							// Determine the new state (1 for draw, 0 for erase)
							const newState = currentInteractionMode === 'draw' ? 1 : 0;
							// Only make a change if the wall state is different at this cell
							if (walls[gridY][gridX] !== newState) {
                                // Record the change (for pending emit on mouseup/touchend)
                                pendingWallChanges[`${gridY}_${gridX}`] = newState;
                                // Update the local wall state immediately for visual feedback
							    walls[gridY][gridX] = newState;
                                maskDirty = true; // Wall changed, need mask update for FoW
							    drawGrid(); // Redraw immediately
                            }
						}
					} else {
                        // --- Handle Hover ---
                        // Handle hover for token name visibility (if no drag, pan, or draw active)
						const tokenInfo = getTokenAtPosition(canvasX, canvasY);
						const newHoveredIndex = tokenInfo ? tokenInfo.index : -1;
						// Only redraw if the hovered state changed
						if (newHoveredIndex !== hoveredTokenIndex) {
							hoveredTokenIndex = newHoveredIndex;
							drawGrid(); // Redraw to update hovered name style/z-index
						}
					}
				}); // End of mousemove listener

				canvas.addEventListener('mouseup', () => {
					resetInteraction(); // Emits wall changes if drawing
				});

				canvas.addEventListener('mouseleave', () => {
                    // Only reset if not currently dragging or panning (e.g., cursor leaves during interaction)
                    // If dragging/panning, the touchend/mouseup will handle the final reset.
                    // This specifically handles the case where the mouse leaves the canvas area.
                    if (!draggedToken && !isPanning && !isDrawing && !isLongPressing && !isContextMenuOpen) {
					    resetInteraction(); // Ensures drawing/panning stops cleanly
                    }
					hoveredTokenIndex = -1; // Clear hover state
                    // Only redraw if the hovered state actually changed
                    if (hoveredTokenIndex !== -1) drawGrid(); // Redraw to remove hover effect/name
				});

				canvas.addEventListener('touchstart', (event) => {
					event.preventDefault();
                    if (isLoading || isContextMenuOpen) { // Prevent interaction while loading or menu is open
                         if (longPressTimeout) clearTimeout(longPressTimeout); // Clear any accidental timeout
                         isLongPressing = false;
                         return;
                    }

					if (event.touches.length === 1) {
						const touch = event.touches[0];
						handleInteractionStart(touch.clientX, touch.clientY);
						longPressStartX = touch.clientX;
						longPressStartY = touch.clientY;
                        // Start timer for long press context menu
                        // Only start if no token was immediately selected for drag (check `draggedToken`)
                        // This avoids showing the context menu immediately on drag start.
                        if (!draggedToken && currentInteractionMode === 'interact') {
                            longPressTimeout = setTimeout(() => {
                                isLongPressing = true;
                                // Check if finger hasn't moved too much - This check is better in touchmove/touchend
                                // Let the timeout just set the flag and call the menu handler
                                handleLongPress(longPressStartX, longPressStartY);

                            }, 500); // 500ms for long press
                        } else {
                             // If a token was selected for drag immediately, it's not a long press intent
                             if (longPressTimeout) clearTimeout(longPressTimeout);
                             isLongPressing = false;
                        }
					} else if (event.touches.length === 2) {
						// Handle pinch-to-zoom
						resetInteraction(); // Stop any dragging/drawing first
                        if (longPressTimeout) clearTimeout(longPressTimeout);
                        isLongPressing = false; // Cancel long press

						const touch1 = event.touches[0];
						const touch2 = event.touches[1];
						pinchStartDistance = Math.hypot(
							touch1.clientX - touch2.clientX,
							touch1.clientY - touch2.clientY
						);
						pinchStartScale = scale;
						pinchStartCenterX = (touch1.clientX + touch2.clientX) / 2;
						pinchStartCenterY = (touch1.clientY + touch2.clientY) / 2;
					} else {
                         // More than 2 touches, ignore or reset
                         resetInteraction();
                         if (longPressTimeout) clearTimeout(longPressTimeout);
                         isLongPressing = false;
                    }
				});

								canvas.addEventListener('touchmove', (event) => {
					event.preventDefault();
                    if (isLoading || isContextMenuOpen) return;

                    // If finger moves significantly during potential long press, cancel it
                    if (longPressTimeout && event.touches.length === 1) {
                         const touch = event.touches[0];
                         const dx = touch.clientX - longPressStartX;
                         const dy = touch.changedTouches[0].clientY - longPressStartY;
                         const distance = Math.sqrt(dx*dx + dy*dy);
                         if (distance > 10) {
                             clearTimeout(longPressTimeout);
                             longPressTimeout = null;
                             isLongPressing = false;
                             // If dragging hadn't started yet but we moved, re-evaluate interaction start at the original touch position
                             // to see if a token was under the initial touch and start dragging if so.
                             if (!draggedToken && !isPanning && !isDrawing) {
                                  const rect = canvas.getBoundingClientRect();
                                  handleInteractionStart(longPressStartX, longPressStartY);
                             }
                         }
                    }

					const rect = canvas.getBoundingClientRect();
					// Check for a single touch (used for drag, pan, or draw)
					if (event.touches.length === 1) {
						const touch = event.touches[0];
						const canvasX = (touch.clientX - rect.left - panX) / scale;
						const canvasY = (touch.clientY - rect.top - panY) / scale;

						// --- Handle token dragging ---
						if (draggedToken) {
                            // Calculate the potential new grid position based on touch position and initial offset
							const tokenSize = draggedToken.size || 1;
							const newX = Math.floor((canvasX - offsetX) / gridSize);
							const newY = Math.floor((canvasY - offsetY) / gridSize);
							const maxX = currentGridWidthCells - tokenSize;
							const maxY = currentGridHeightCells - tokenSize;

							// Clamp the *intended* final position to grid bounds FIRST
							const clampedX = Math.max(0, Math.min(newX, maxX));
							const clampedY = Math.max(0, Math.min(newY, maxY));

                            // --- Implement Single-Step Collision Check ---
                            // Only perform this logic if the intended clamped position is DIFFERENT from the token's current cell
                            if (draggedToken.x !== clampedX || draggedToken.y !== clampedY) {

                                const currentX = draggedToken.x;
                                const currentY = draggedToken.y;

                                // Calculate the proposed next step: move one cell towards the clamped destination
                                // Math.sign gives -1, 0, or 1
                                let targetX = currentX + Math.sign(clampedX - currentX);
                                let targetY = currentY + Math.sign(clampedY - currentY);

                                // Re-clamp this single step to ensure it's still within bounds (should be, but safe)
                                targetX = Math.max(0, Math.min(targetX, maxX));
                                targetY = Math.max(0, Math.min(targetY, maxY));

                                // Now check for collision at this *single step* target cell
                                if (!isCollision(targetX, targetY, draggedToken, walls, currentGridWidthCells, currentGridHeightCells)) {
                                    // If there is NO collision at the single step target:
                                    // Update the token's local position to this new single step cell
                                    draggedToken.x = targetX;
                                    draggedToken.y = targetY;
                                    // console.log(`Touch moving token ${draggedToken.name} to x: ${draggedToken.x}, y: ${draggedToken.y}`); // COMMENTED OUT
                                    // Emit the updated position to the server (the server will also validate)
                                    socket.emit('moveToken', {
                                        tokenId: draggedToken.id,
                                        x: draggedToken.x,
                                        y: draggedToken.y,
                                        rotation: draggedToken.rotation
                                    });
                                    maskDirty = true; // Token moved, need to recalculate mask (for FoW)
                                    drawGrid(); // Redraw immediately for smooth drag feedback
                                } else {
                                    // If there IS a collision at the single step target:
                                    // The token's position is NOT updated. It stays in its last valid cell.
                                    // This prevents moving into the wall, even if the touch jumps over it.
                                    console.log(`Collision detected for ${draggedToken.name} at [${targetX}, ${targetY}]. Blocking move.`);
                                    // Optional: Add visual feedback here (e.g., temporary red tint)
                                }
                            }
                            // If the intended clamped position is the same as current, do nothing (token didn't move cells).

						// --- Handle panning ---
						} else if (isPanning && !isLongPressing) { // Handle panning if no token is dragged and not a potential long press
							panX += touch.clientX - startX;
							panY += touch.clientY - startY;
							startX = touch.clientX;
							startY = touch.clientY;
							drawGrid();

						// --- Handle wall drawing/erasing ---
						} else if (isDrawing && currentRole === 'dm' && (currentInteractionMode === 'draw' || currentInteractionMode === 'erase')) { // Only draw/erase if in correct mode and DM
							const gridX = Math.floor(canvasX / gridSize);
							const gridY = Math.floor(canvasY / gridSize);
							// Check if the touch is within grid bounds
							if (gridX >= 0 && gridX < currentGridWidthCells && gridY >= 0 && gridY < currentGridHeightCells) {
								// Ensure wall array is initialized for the row if it doesn't exist
								if (!walls[gridY]) walls[gridY] = Array(currentGridWidthCells).fill(0);
								// Determine the new state (1 for draw, 0 for erase)
								const newState = currentInteractionMode === 'draw' ? 1 : 0;
								// Only make a change if the wall state is different at this cell
								if (walls[gridY][gridX] !== newState) {
                                    // Record the change (for pending emit on touchend)
                                    pendingWallChanges[`${gridY}_${gridX}`] = newState;
                                    // Update the local wall state immediately for visual feedback
								    walls[gridY][gridX] = newState;
                                    maskDirty = true; // Wall changed, need mask update for FoW
								    drawGrid(); // Redraw immediately
                                }
							}
						}
					// --- Handle Pinch-to-Zoom ---
					} else if (event.touches.length === 2) { // Handle two touches for pinch-to-zoom
						// Ensure any pending single-touch interactions are reset
						resetInteraction();
						if (longPressTimeout) clearTimeout(longPressTimeout);
						isLongPressing = false;

                        // Pinch-to-zoom logic
						const touch1 = event.touches[0];
						const touch2 = event.touches[1];
						// Calculate distance between touches
						const newDistance = Math.hypot(
							touch1.clientX - touch2.clientX,
							touch1.clientY - touch2.clientY
						);
						// Calculate the center point of the pinch
						const newCenterX = (touch1.clientX + touch2.clientX) / 2;
						const newCenterY = (touch1.clientY + touch2.clientY) / 2;

						// Calculate the zoom factor based on the change in pinch distance
						const scaleFactor = newDistance / pinchStartDistance;
						// Apply the zoom factor to the previous scale, clamping between min/max
						const newScale = pinchStartScale * scaleFactor;
						scale = Math.max(0.2, Math.min(newScale, 5)); // Clamp scale between 0.2x and 5x

                        // Adjust pan to keep the pinch center point (in world coordinates) stable on the screen
						const rect = canvas.getBoundingClientRect(); // Recalculate rect just in case (might change during pinch)
						// Calculate the canvas coordinates of the initial pinch center in the *old* scale
						const canvasCenterX = (pinchStartCenterX - rect.left - panX) / pinchStartScale;
						const canvasCenterY = (pinchStartCenterY - rect.top - panY) / pinchStartScale;
						// Calculate the new pan offset needed to keep that canvas point under the new pinch center
						panX = newCenterX - rect.left - canvasCenterX * scale;
						panY = newCenterY - rect.top - canvasCenterY * scale;

						// Update pinch start values for the next touchmove event
						pinchStartDistance = newDistance;
						pinchStartScale = scale;
						pinchStartCenterX = newCenterX;
						pinchStartCenterY = newCenterY;

						drawGrid(); // Redraw after zoom/pan
					}
					// If more than 2 touches, we ignore them (handled by initial check in touchstart)
				}); // End of touchmove listener

				canvas.addEventListener('touchend', (event) => {
                     // If a long press timer was active, clear it and check if it was a tap vs long press
                    if (longPressTimeout) {
                         clearTimeout(longPressTimeout);
                         longPressTimeout = null;
                         // If it was a short tap (not a drag or long press), handle interaction start/click
                         // Check if touch ended *without* significant movement and was not flagged as long press
                         const dx = event.changedTouches[0].clientX - longPressStartX;
                         const dy = event.changedTouches[0].clientY - longPressStartY;
                         const distance = Math.sqrt(dx*dx + dy*dy);
                         // If interaction didn't turn into a drag/pan AND distance is small, treat as a click/tap
                         if (!draggedToken && !isPanning && !isDrawing && distance < 10 && !isLongPressing) {
                            // Simulate a click interaction at the start position
                             handleInteractionStart(longPressStartX, longPressStartY); // This will either start drag (if it wasn't picked up before) or do nothing if no token/pan/draw
                             resetInteraction(); // Then reset immediately as it was just a tap
                         }
                         isLongPressing = false; // Reset flag
                    }

                    // Reset general interaction state *only* if all touches are lifted
                    if (event.touches.length === 0) {
                        resetInteraction(); // Emits wall changes if drawing
                    }
				});

				canvas.addEventListener('touchcancel', () => {
					resetInteraction();
                     if (longPressTimeout) {
                         clearTimeout(longPressTimeout);
                         longPressTimeout = null;
                         isLongPressing = false;
                    }
				});

				canvas.addEventListener('wheel', (event) => {
					event.preventDefault();
					const rect = canvas.getBoundingClientRect();
					const mouseX = event.clientX - rect.left;
					const mouseY = event.clientY - rect.top;

					const zoomSpeed = 0.0005; // Slower zoom speed
					// Use exponential scaling for smoother zoom levels
					const zoomFactor = Math.exp(-event.deltaY * zoomSpeed);

					const canvasX = (mouseX - panX) / scale;
					const canvasY = (mouseY - panY) / scale;

					const newScale = scale * zoomFactor;
					scale = Math.max(0.2, Math.min(newScale, 5)); // Clamp scale between 0.2x and 5x

					// Adjust pan to zoom into the mouse position
					panX = mouseX - canvasX * scale;
					panY = mouseY - canvasY * scale;

					drawGrid();
				});

				window.addEventListener('resize', resizeCanvas);

				// Login handler
				document.getElementById('loginButton').addEventListener('click', () => {
					username = document.getElementById('usernameInput').value.trim();
					currentRole = document.getElementById('roleSelect').value;
					if (!username) {
						showNotification('Please enter a username.', true);
						return;
					}
					if (!socket || !socket.connected) {
						showNotification('Not connected to server. Cannot login.', true);
						return;
					}
					console.log(`Attempting login as ${username} (${currentRole})`);
					socket.emit('login', { username, role: currentRole });
				});

					socket.on('roleAssigned', ({ role, username: assignedUsername }) => {
					console.log(`Role assigned by server: ${role}, Username: ${assignedUsername}`);
					currentRole = role;
					username = assignedUsername;
					document.getElementById('loginScreen').classList.add('hidden');
					document.body.classList.add(`role-${currentRole}`);
					updateDarkModeStyles(document.body.classList.contains('dark-mode'));
					showNotification(`Logged in as ${username} (${role})`);

                    // The server address display logic is handled in determineServerUrl
                    // based on whether it's running in Electron or a browser.
                    // It doesn't need to be re-run here on role assignment.
                    // If you wanted to dynamically update it (e.g., if IP changes mid-session, unlikely)
                    // you'd need a server event for that.
                    // For now, remove the redundant display update from here.

                    // Recalculate visibility for the new role
                    maskDirty = true;
					drawGrid(); // Ensure redraw with correct mask
				});

				// Initial state load
				socket.on('init', (data) => {
					isLoading = true; // Prevent interaction while loading
					console.log("Initial state received:", data); // Added log to see received data structure

					// Map tokens, ensuring correct structure and applying defaults for new properties
					// Correctly ensure numeric/boolean types here using Number() and Boolean()
					tokensData = (data.tokens || []).map(token => ({
						...token, // Keep existing properties
						// Ensure numeric positions and add default visibility/light properties if missing
						x: Number.isFinite(token.x) ? Number(token.x) : Math.floor((data.gridSize?.width || gridSizeOptions.small.width) / 2),
						y: Number.isFinite(token.y) ? Number(token.y) : Math.floor((data.gridSize?.height || gridSizeOptions.small.height) / 2),
						sightRadius: Number.isFinite(token.sightRadius) ? Number(token.sightRadius) : 0, // Ensure numeric exists
						isLightSource: Boolean(token.isLightSource), // Ensure boolean exists
						brightRange: Number.isFinite(token.brightRange) ? Number(token.brightRange) : 0, // Ensure numeric exists
						dimRange: Number.isFinite(token.dimRange) ? Number(token.dimRange) : 0,         // Ensure numeric exists
						// Ensure other potential missing defaults from older formats
						maxHP: token.maxHP !== undefined ? Number(token.maxHP) : 0, // Ensure numeric
						hp: token.hp !== undefined ? Number(token.hp) : 0,           // Ensure numeric
						initiative: token.initiative !== undefined ? Number(token.initiative) : 0, // Ensure numeric
						ac: token.ac !== undefined ? Number(token.ac) : 0,             // Ensure numeric
						rotation: token.rotation !== undefined ? Number(token.rotation) : 0,   // Ensure numeric
						isMinion: token.isMinion !== undefined ? Boolean(token.isMinion) : false, // Ensure boolean
						owner: token.owner || null,
						parentOwner: token.parentOwner || null,
						 // Ensure token size is valid
						size: Number.isFinite(token.size) && token.size > 0 ? Number(token.size) : 1, // Ensure numeric
						// imageUrl/backgroundColor/imageFilename should also be handled if needed for merging
						imageUrl: token.imageUrl || null,
						backgroundColor: token.backgroundColor || null,
						imageFilename: token.imageFilename || null,
					}));
					console.log('Initialized tokens:', tokensData.map(t => ({ id: t.id, name: t.name, x: t.x, y: t.y, owner: t.owner, sight: t.sightRadius, light: t.isLightSource ? `${t.brightRange}/${t.dimRange}` : 'No' })));


					currentGridWidthCells = data.gridSize?.width || gridSizeOptions.small.width;
					currentGridHeightCells = data.gridSize?.height || gridSizeOptions.small.height;
					walls = normalizeWalls(data.walls, currentGridWidthCells, currentGridHeightCells);

					// View state from state file is currently ignored on init, relying on client's default or reset view.
					// If you wanted to load view state:
					// scale = data.viewState?.scale || 1;
					// panX = data.viewState?.panX || 0;
					// panY = data.viewState?.panY || 0;
					// Centering logic handled by resizeCanvas after initial load

					// --- Corrected: These state updates must be *after* the tokensData and grid size are loaded ---
					isGridVisible = data.isGridVisible !== undefined ? Boolean(data.isGridVisible) : true; // Ensure boolean
					isMapFullyVisible = data.isMapFullyVisible !== undefined ? Boolean(data.isMapFullyVisible) : false; // NEW: Init map visibility toggle state (Ensure boolean)

					// Set grid size select value based on loaded size
					const loadedSizeKey = Object.keys(gridSizeOptions).find(
						key => gridSizeOptions[key].width === currentGridWidthCells &&
							   gridSizeOptions[key].height === currentGridHeightCells
					) || 'small'; // Default to 'small' if loaded size doesn't match a preset
					gridSizeSelect.value = loadedSizeKey;

					// --- ADDED: Update button text and class based on loaded state (DM only) ---
					// This runs after init, the role will be set shortly after by roleAssigned
					// It's okay to set these here, they will be corrected if needed in roleAssigned or subsequent updates.
					// Best practice is often to put this in roleAssigned after init has populated state, but this works too.
					 if (currentRole === 'dm') { // Check if user is DM before touching DM-only buttons
						if (toggleGridButton) { // Check if button element exists
						   toggleGridButton.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
						   toggleGridButton.classList.toggle('feature-active', !isGridVisible); // Active when grid is HIDDEN
						}
						if (toggleAllVisibleButton) { // Check if button element exists
						   toggleAllVisibleButton.textContent = isMapFullyVisible ? 'Hide Map' : 'Show Map';
						   toggleAllVisibleButton.classList.toggle('feature-active', isMapFullyVisible); // Active when map is FULLY VISIBLE
						}
					 }
					// --- END ADDED ---


					tokensData.forEach(preloadTokenImage); // Preload images asynchronously
					loadBackgroundImage(data.backgroundImageUrl || ''); // Load background asynchronously

					maskDirty = true; // State initialized, need to calculate and build mask
					resizeCanvas(); // Ensure canvas size matches window and mask canvas size is set, also calls drawGrid
					// drawGrid is called recursively by requestAnimationFrame

					isLoading = false; // Loading is complete
				});

				// Listen for full state updates (used by importState on the server)
				socket.on('fullStateUpdate', (state) => {
					 isLoading = true; // Prevent interaction while updating
					 console.log("Full state update received:", state); // Added log

					 // Map tokens, ensuring correct structure and applying defaults for new properties
					 tokensData = (state.tokens || []).map(token => ({
						 ...token, // Keep existing properties
						 // Ensure numeric positions and add default visibility/light properties if missing
						 x: Number.isFinite(token.x) ? Number(token.x) : Math.floor((state.gridSize?.width || gridSizeOptions.small.width) / 2),
						 y: Number.isFinite(token.y) ? Number(token.y) : Math.floor((state.gridSize?.height || gridSizeOptions.small.height) / 2),
						 sightRadius: Number.isFinite(token.sightRadius) ? Number(token.sightRadius) : 0, // Ensure numeric exists
						 isLightSource: Boolean(token.isLightSource), // Ensure boolean exists
						 brightRange: Number.isFinite(token.brightRange) ? Number(token.brightRange) : 0, // Ensure numeric exists
						 dimRange: Number.isFinite(token.dimRange) ? Number(token.dimRange) : 0,         // Ensure numeric exists
						 // Include other potential missing defaults from older formats
						 maxHP: token.maxHP !== undefined ? Number(token.maxHP) : 0, // Ensure numeric
						 hp: token.hp !== undefined ? Number(token.hp) : 0,           // Ensure numeric
						 initiative: token.initiative !== undefined ? Number(token.initiative) : 0, // Ensure numeric
						 ac: token.ac !== undefined ? Number(token.ac) : 0,             // Ensure numeric
						 rotation: token.rotation !== undefined ? Number(token.rotation) : 0,   // Ensure numeric
						 isMinion: token.isMinion !== undefined ? Boolean(token.isMinion) : false, // Ensure boolean
						 owner: token.owner || null,
						 parentOwner: token.parentOwner || null,
						  // Ensure token size is valid
						 size: Number.isFinite(token.size) && token.size > 0 ? Number(token.size) : 1, // Ensure numeric
						 // imageUrl/backgroundColor/imageFilename should also be handled if needed for merging
						 imageUrl: token.imageUrl || null,
						 backgroundColor: token.backgroundColor || null,
						 imageFilename: token.imageFilename || null,

					 }));
					 // console.log('Full state update tokens processed:', tokensData.map(t => ({ id: t.id, name: t.name, x: t.x, y: t.y, owner: t.owner, sight: t.sightRadius, light: t.isLightSource ? `${t.brightRange}/${t.dimRange}` : 'No' })));


					 currentGridWidthCells = state.gridSize?.width || gridSizeOptions.small.width;
					 currentGridHeightCells = state.gridSize?.height || gridSizeOptions.small.height;
					 walls = normalizeWalls(state.walls, currentGridWidthCells, currentGridHeightCells);
					 backgroundImageUrl = state.backgroundImageUrl || '';

					 // Load view state if present (from import)
					 scale = state.viewState?.scale || 1;
					 panX = state.viewState?.panX || 0;
					 panY = state.viewState?.panY || 0;

					 // --- Corrected: These state updates must be *after* the tokensData and grid size are loaded ---
					 isGridVisible = state.isGridVisible !== undefined ? Boolean(state.isGridVisible) : true; // Ensure boolean
					 isMapFullyVisible = state.isMapFullyVisible !== undefined ? Boolean(state.isMapFullyVisible) : false; // NEW: Update map visibility state (Ensure boolean)


					 const loadedSizeKey = Object.keys(gridSizeOptions).find(
						 key => gridSizeOptions[key].width === currentGridWidthCells &&
								gridSizeOptions[key].height === currentGridHeightCells
					 ) || 'small';
					 gridSizeSelect.value = loadedSizeKey;

					 // --- ADDED: Update button text and class based on loaded state (DM only) ---
					 // This runs after a full state import/update. The role should already be set.
					 if (currentRole === 'dm') { // Check if user is DM before touching DM-only buttons
						 if (toggleGridButton) { // Check if button element exists
							toggleGridButton.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
							toggleGridButton.classList.toggle('feature-active', !isGridVisible); // Active when grid is HIDDEN
						 }
						 if (toggleAllVisibleButton) { // Check if button element exists
							toggleAllVisibleButton.textContent = isMapFullyVisible ? 'Hide Map' : 'Show Map';
							toggleAllVisibleButton.classList.toggle('feature-active', isMapFullyVisible); // Active when map is FULLY VISIBLE
						 }
					 }
					 // --- END ADDED ---


					 tokensData.forEach(preloadTokenImage); // Preload images for all tokens
					 loadBackgroundImage(backgroundImageUrl);

					 maskDirty = true; // State updated, need to calculate and build mask
					 resizeCanvas(); // Ensure canvas size and mask canvas size are set, calls drawGrid
					 // drawGrid is called recursively
					 console.log("Full state update received and processed.");
					 isLoading = false; // Finished loading/processing
				});


				socket.on('updateTokens', (tokens) => {
					// Merge updates to preserve local imageObj and ensure new properties
					tokensData = tokens.map(updatedToken => {
                        const existingToken = tokensData.find(t => t.id === updatedToken.id);
                        // Use existing imageObj if available, otherwise update
                        const imageObj = existingToken ? existingToken.imageObj : null;

                         // Ensure numeric positions and default sightRadius/light properties
                         const x = Number.isFinite(updatedToken.x) ? updatedToken.x : existingToken?.x || Math.floor(currentGridWidthCells / 2);
                         const y = Number.isFinite(updatedToken.y) ? updatedToken.y : existingToken?.y || Math.floor(currentGridHeightCells / 2);
                         const sightRadius = Number.isFinite(updatedToken.sightRadius) ? updatedToken.sightRadius : (existingToken?.sightRadius || 0);
                         const isLightSource = Boolean(updatedToken.isLightSource); // Ensure boolean
                         const brightRange = Number.isFinite(updatedToken.brightRange) ? updatedToken.brightRange : (existingToken?.brightRange || 0);
                         const dimRange = Number.isFinite(updatedToken.dimRange) ? updatedToken.dimRange : (existingToken?.dimRange || 0);

                        return {
                            ...existingToken, // Keep existing properties not explicitly updated
                            ...updatedToken, // Apply updated properties
                            x, y, sightRadius, isLightSource, brightRange, dimRange, // Ensure numeric + default
                            imageObj: imageObj // Keep the loaded image object
                        };
                    });

                    // Handle removed tokens (filter out any tokens no longer in the updated list)
                    tokensData = tokensData.filter(token => tokens.some(t => t.id === token.id));

                    // Re-check hovered/dragged index in case the list changed
                    if (draggedToken && !tokensData.some(t => t.id === draggedToken.id)) {
                        draggedToken = null;
                        draggedTokenIndex = -1;
                    }
                    if (hoveredTokenIndex !== -1 && !tokensData.some(t => t.id === tokensData[hoveredTokenIndex]?.id)) {
                         hoveredTokenIndex = -1;
                    }


					// console.log('Updated tokens:', tokensData.map(t => ({ id: t.id, name: t.name, x: t.x, y: t.y, owner: t.owner, sight: t.sightRadius, light: t.isLightSource ? `${t.brightRange}/${t.dimRange}` : 'No' }))); // Less spammy token log
                    // Preload images for any newly added tokens that weren't merged
                    tokensData.forEach(token => {
                         if (!token.imageObj && token.imageUrl) {
                              preloadTokenImage(token);
                         }
                    });

                    maskDirty = true; // Tokens moved or stats/light updated, need mask update
					drawGrid(); // Redraw the grid
				});

				// Server emits updateWalls. Client receives and updates local walls.
				socket.on('updateWalls', (newWalls) => {
                    // updateGridSize also sends updateWalls, which will trigger fullStateUpdate anyway.
                    // This handler is mainly for continuous drawing/erasing.
                    // Fog of War requires mask update whenever walls change.
                    walls = normalizeWalls(newWalls, currentGridWidthCells, currentGridHeightCells);
                    maskDirty = true; // Walls changed, need mask update
                    drawGrid(); // Redraw the grid
				});

				socket.on('updateGridVisibility', (newIsGridVisible) => {
					isGridVisible = newIsGridVisible;
					if (currentRole === 'dm' && toggleGridButton) {
						toggleGridButton.textContent = isGridVisible ? 'Hide Grid' : 'Show Grid';
						toggleGridButton.classList.toggle('feature-active', !isGridVisible); // Active when grid is HIDDEN
					}
					maskDirty = true; // Grid visibility changed, need mask update
					drawGrid();
				});
				
				// Socket Listener: Handle map visibility toggle state updates
				socket.on('mapVisibilityToggled', (newState) => {
					isMapFullyVisible = Boolean(newState); // Ensure the state is a boolean
					console.log(`Map visibility toggle state received: ${isMapFullyVisible}`);

					// --- ADDED: Update button text and class ---
					// We check for `currentRole === 'dm'` here because only DMs see the button
					if (currentRole === 'dm' && toggleAllVisibleButton) { // Added the check back
						toggleAllVisibleButton.textContent = isMapFullyVisible ? 'Hide Map' : 'Show Map';
						toggleAllVisibleButton.classList.toggle('feature-active', isMapFullyVisible); // Active when map is FULLY VISIBLE
					}
					// --- END ADDED ---
					// Flag the mask as dirty because the visibility state has changed, requiring a rebuild/clear
					maskDirty = true;
					drawGrid(); // Request a redraw to apply the visibility state
				});

				socket.on('updateBackground', (url) => {
					loadBackgroundImage(url); // loadBackgroundImage already calls drawGrid
				});

				socket.on('updateGridSize', (gridSize) => {
					currentGridWidthCells = gridSize.width;
					currentGridHeightCells = gridSize.height;

					// Try to find a matching preset key
					const loadedSizeKey = Object.keys(gridSizeOptions).find(
						key => gridSizeOptions[key].width === currentGridWidthCells &&
							   gridSizeOptions[key].height === currentGridHeightCells
					);

					if (loadedSizeKey) {
						// If it matches a preset, select that preset and hide custom inputs
						gridSizeSelect.value = loadedSizeKey;
						if (customSizeInputsDiv) { // Check if element exists
							 customSizeInputsDiv.style.display = 'none';
						}
					} else {
						// If it doesn't match a preset, select "Custom" and show/update inputs
						gridSizeSelect.value = 'custom';
						if (customSizeInputsDiv && customWidthInput && customHeightInput) { // Check elements exist
							customWidthInput.value = currentGridWidthCells;
							customHeightInput.value = currentGridHeightCells;
							customSizeInputsDiv.style.display = 'block'; // Or 'flex'
						}
					}

					// --- Important: Keep the rest of the original handler ---
					maskDirty = true; // Grid size changed, need mask update
					resizeCanvas();   // Updates canvas size AND mask canvas size, calls drawGrid
				});


				socket.on('error', (message) => {
					showNotification(message, true);
                    // If username is in use, force the login screen back open
					if (message === 'Username already in use') {
						document.getElementById('loginScreen').classList.remove('hidden');
						// Reset role and username on client if login failed due to name conflict
                        currentRole = null;
                        username = null;
						document.body.className = ''; // Remove role class
                         // Re-enable login button if it was disabled during connection attempts
                         document.getElementById('loginButton').disabled = false;
                         document.getElementById('loginButton').textContent = 'Join';
					}
				});

				socket.on('saveSuccess', (message) => {
					showNotification(message);
				});

				socket.on('clients', (clientUsernames) => { // Server now sends usernames
					// console.log('Connected clients:', clientUsernames); // Keep console cleaner
				});


			} // End initializeSocket

			// Start the process by determining the server URL and then initializing the socket
			determineServerUrl();
		}); // End DOMContentLoaded listener
	</script>
	</body>
</html>